<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <title>簡譜和弦轉換</title>
  <style>
    body { 
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", Arial, sans-serif; 
      background-color: #f9f9f9;
      margin: 0;
      padding: 20px;
      color: #333;
    }
    .hidden { display: none; }
    
    /* 標題樣式 */
    .app-header {
      text-align: center;
      margin-bottom: 20px;
    }
    .app-title {
      font-size: 36px;
      font-weight: bold;
      color: #0891b2;
      margin-bottom: 20px;
    }
    
    /* 分頁按鈕樣式 */
    .tabs {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-bottom: 25px;
    }
    .tab-btn {
      min-width: 120px;
      padding: 12px 20px;
      border: 2px solid #22c3ee;
      border-radius: 25px;
      background: white;
      color: #22c3ee;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      text-align: center;
      transition: all 0.2s ease;
    }
    .tab-btn:hover {
      background: #f0f9ff;
    }
    .tab-btn[aria-selected="true"] {
      background: #e0f2fe;
      box-shadow: 0 0 0 3px rgba(34,195,238,0.2) inset;
    }
    
    /* 工作區域樣式 */
    .workspace-frame {
      border: 4px solid #22c3ee;
      border-radius: 48px;
      padding: 30px;
      background: white;
      min-height: 400px;
      max-width: 1100px;
      margin: 0 auto;
      position: relative;
    }
    
    /* 原有的疊圖樣式 */
    .overlay-stage { position: relative; display: inline-block; }
    .overlay-stage > img { display: block; max-width: 100%; height: auto; }
    .tag { position: absolute; box-sizing: border-box; border-radius: 4px; padding: 0 4px; line-height: 1; display: flex; align-items: center; justify-content: center; font-family: monospace; }
    .tag.chord { background: rgba(0,0,0,.88); color: #ffd700; font-weight: 700; }
    .tag.lyric { background: rgba(255,255,255,.75); color: #111; border: 1px solid #e5e7eb; }
    
    /* 按鈕樣式 */
    #to-export-btn, #to-transpose-btn, #transpose-btn, #recognize-btn {
      position: relative;
      z-index: 10;
      cursor: pointer;
      padding: 8px 16px;
      background: #f8f8f8;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-top: 10px;
    }
    
    /* 確保疊圖中的標籤不會攔截點擊事件 */
    .overlay-stage .tag {
      pointer-events: none;
    }
    .overlay-stage:hover .tag {
      pointer-events: auto;
    }
    
    /* 上傳區域與檔案預覽樣式 */
    .upload-area {
      border: 2px dashed #22c3ee;
      border-radius: 10px;
      padding: 40px 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .upload-area:hover {
      background-color: #f0f9ff;
      border-color: #0891b2;
    }
    .upload-area .upload-icon {
      margin: 0 auto 15px;
    }

    /* 工作區提示文字 */
    .workspace-hint {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #0891b2;
      font-size: 18px;
    }

    /* 檔案預覽樣式 */
    .file-preview-area {
      margin: 20px 0;
      border-radius: 10px;
      overflow: hidden;
      background: #f8f8f8;
    }
    .file-info {
      padding: 10px 15px;
      background: #e0f2fe;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .file-name {
      font-weight: bold;
      color: #0891b2;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .file-size {
      color: #555;
      font-size: 0.9em;
    }
    .preview-container {
      padding: 15px;
      text-align: center;
      overflow: hidden; /* 確保溢出的內容被隱藏 */
      min-height: 600px; /* 提供足夠的空間給放大後的圖片 */
    }
    .preview-container img {
      max-width: 100%;  /* 保持寬度適應容器 */
      max-height: 600px; /* 從原本的 300px 放大到 600px */
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      transform: scale(2); /* 加入縮放效果 */
      transform-origin: center top; /* 從中央頂部開始縮放 */
      margin: 80px 0; /* 增加上下邊距以容納放大的內容 */
    }

    /* 按鈕樣式統一 */
    #recognize-btn, #to-transpose-btn, #transpose-btn, #to-export-btn {
      background-color: #22c3ee;
      color: white;
      border: none;
      border-radius: 25px;
      padding: 10px 20px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-top: 15px;
    }
    #recognize-btn:hover, #to-transpose-btn:hover, #transpose-btn:hover, #to-export-btn:hover {
      background-color: #0891b2;
    }
    #recognize-btn:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }

    /* 辨識編輯分頁樣式 */
    .recognition-container {
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin-bottom: 20px;
    }
    .recognition-compare-area {
      display: flex;
      gap: 20px;
      align-items: flex-start;
    }
    .original-image-container,
    .recognition-result-container {
      flex: 1;
      min-width: 0;
    }
    .recognition-result-area {
      flex: 3;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .edit-panel {
      width: 100%;
      background: #f8f8f8;
      border-radius: 10px;
      padding: 15px;
    }
    #text-editor {
      width: 100%;
      min-height: 600px;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-family: monospace;
      font-size: 14px;
      line-height: 1.5;
      resize: vertical;
    }
    .original-image-container,
    .recognition-result-container {
      flex: 1;
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 10px;
      min-height: 400px;
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
      gap: 8px; /* 內部元素間距，避免與下方框線視覺貼合 */
    }
    .original-image-container h3,
    .recognition-result-container h3 {
      margin-top: 0;
      color: #0891b2;
      font-size: 18px;
      margin-bottom: 10px;
    }
    #recognition-status {
      font-size: 14px;
      color: #888;
      font-weight: normal;
    }
    .recognition-controls {
      display: flex;
      justify-content: space-between;
      margin-top: 20px;
    }
    .overlay-container {
      flex: 1;
      position: relative;
      border: 1px dashed #ccc;
      background-color: #fcfcfc;
      overflow: auto;
    }
    .edit-tools {
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap;
    }
    .edit-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      background-color: #e0f2fe;
      color: #0891b2;
      border: none;
      padding: 8px 16px;
      border-radius: 20px;
      cursor: pointer;
      font-weight: bold;
    }
    .edit-btn:hover {
      background-color: #bae6fd;
    }
    .edit-options {
      margin-top: 15px;
      padding: 12px;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 8px;
    }
    .edit-option {
      margin-bottom: 12px;
    }
    .edit-option label {
      display: block;
      margin-bottom: 5px;
      color: #555;
      font-size: 14px;
    }
    .edit-option select, 
    .edit-option input {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .edit-actions {
      display: flex;
      gap: 10px;
    }
    .edit-action-btn {
      flex: 1;
      padding: 8px;
      border: none;
      border-radius: 4px;
      background-color: #22c3ee;
      color: white;
      cursor: pointer;
    }
    .edit-action-btn.danger {
      background-color: #ff6b6b;
    }
    .edit-action-btn:hover {
      opacity: 0.9;
    }
    .edit-help {
      background: #f0f9ff;
      border-radius: 8px;
      padding: 12px;
      margin-top: 20px;
    }
    .edit-help h4 {
      margin-top: 0;
      color: #0891b2;
      font-size: 16px;
      margin-bottom: 8px;
    }
    .edit-help ul {
      margin: 0;
      padding-left: 20px;
      color: #555;
    }
    .edit-help li {
      margin-bottom: 6px;
      font-size: 14px;
    }
    .action-btn {
      padding: 10px 20px;
      border-radius: 25px;
      border: none;
      font-weight: bold;
      cursor: pointer;
    }
    .action-btn.primary {
      background-color: #22c3ee;
      color: white;
    }
    .action-btn.secondary {
      background-color: #e0f2fe;
      color: #0891b2;
      border: 1px solid #bae6fd;
    }
    .action-btn:hover {
      opacity: 0.9;
    }
    /* 和弦與歌詞的可編輯樣式 */
    .tag.editable {
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .tag.editable:hover {
      box-shadow: 0 0 0 2px rgba(34, 195, 238, 0.5);
    }
    .tag.editable.selected {
      box-shadow: 0 0 0 3px #22c3ee;
    }
    .tag.chord.editable {
      border: 1px dashed #ffd700;
    }
    .tag.lyric.editable {
      border: 1px dashed #22c3ee;
    }
    /* 新增項目的提示樣式 */
    .add-item-hint {
      position: absolute;
      background-color: rgba(34, 195, 238, 0.1);
      border: 2px dashed #22c3ee;
      padding: 15px;
      border-radius: 8px;
      color: #0891b2;
      font-size: 14px;
      text-align: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .overlay-container.edit-mode:hover .add-item-hint {
      opacity: 1;
    }

    /* 辨識編輯頁面並排顯示樣式 */
    .recognition-container {
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin-bottom: 20px;
    }

    /* 原始圖與辨識結果並排 */
    .recognition-compare-area {
      display: flex;
      gap: 20px;
      width: 100%;
      align-items: stretch; /* 兩側等高 */
    }

    .original-image-container,
    .recognition-result-container {
      flex: 1;
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 10px;
      min-height: 400px;
      display: flex;
      flex-direction: column;
    }

    .original-image-container h3,
    .recognition-result-container h3 {
      margin-top: 0;
      color: #0891b2;
      font-size: 18px;
      margin-bottom: 10px;
    }

    /* 圖片容器樣式 */
    .image-container {
      flex: 1 1 auto;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .image-container img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    /* 左側原始圖片：使用原尺寸，超出則顯示捲軸 */
    .original-image-container .image-container {
      align-items: flex-start;
      justify-content: flex-start;
      overflow: auto;
    }
    .original-image-container .image-container img {
      max-width: none;
      max-height: none;
      width: auto;
      height: auto;
      object-fit: initial;
      display: block;
    }

    /* 辨識結果容器 */
    .overlay-container {
      flex: 1;
      position: relative;
      border: 1px dashed #ccc;
      background-color: #fcfcfc;
      overflow: auto;
    }

    /* 編輯面板置於下方 */
    .edit-panel {
      width: 100%;
      background: #f8f8f8;
      border-radius: 10px;
      padding: 15px;
    }

    /* 工具列排成水平 */
    .edit-tools {
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap;
    }

    /* 可編輯標籤樣式 */
    .tag.editable {
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .tag.editable:hover {
      box-shadow: 0 0 0 2px rgba(34, 195, 238, 0.5);
    }

    .tag.editable.selected {
      box-shadow: 0 0 0 3px #22c3ee;
    }
    .tag.chord.editable {
      border: 1px dashed #ffd700;
    }
    .tag.lyric.editable {
      border: 1px dashed #22c3ee;
    }
    /* 文字模式切換列 */
    .result-mode-switch { display:flex; gap:8px; align-items:center; margin:6px 0 10px; }
    .mode-btn {
      padding:6px 10px; border:1px solid #bae6fd; border-radius:9999px;
      background:#e0f2fe; color:#0891b2; font-weight:700; cursor:pointer;
    }
    .mode-btn.active { background:#22c3ee; color:#fff; border-color:#22c3ee; }

    /* 純文字編輯器 */
    #text-editor-wrap {
      margin-top:8px;
      margin-bottom:8px;
      display:flex;
      flex-direction:column;
      flex:1;           /* 佔滿右側容器剩餘高度 */
      min-height:0;     /* 允許內部子項縮放 */
    }
    #text-editor {
      width:100%;
      /* 在 flex 佈局下以 flex 撐滿，不再用內容自動高度 */
      flex: 1 1 auto;
      min-height:0;
      height:auto;
      resize:vertical; /* 可手動拉高，若需嚴格等高可移除此設定 */
      white-space:pre;
      line-height:1.6;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      border:1px solid #e5e7eb;
      border-radius:8px;
      padding:10px;
      background:#fff;
      overflow-y:auto;
      box-sizing: border-box;
      /* 取消先前的 max-height 限制，讓其等高於左側容器 */
    }

    /* 文字工具列 */
    .text-tools { display:flex; gap:8px; justify-content:flex-end; margin:6px 0; }
    .tool-btn { padding:6px 10px; border:1px solid #d1d5db; border-radius:6px; background:#fff; cursor:pointer; font-size:12px; }
    .tool-btn:hover { background:#f3f4f6; }
    .tool-btn.primary { background:#22c3ee; color:#fff; border-color:#22c3ee; }

  /* 匯出預覽樣式 */
  .export-toolbar { display:flex; gap:10px; margin-bottom:10px; flex-wrap:wrap; }
  .export-btn { padding:8px 12px; border:1px solid #d1d5db; border-radius:8px; background:#fff; cursor:pointer; }
  .export-btn.primary { background:#10b981; border-color:#10b981; color:#fff; }
  #export-canvas-wrap { border:1px solid #e5e7eb; border-radius:8px; background:#fff; padding:16px; overflow:auto; }
  #export-preview { white-space:pre; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; line-height:1.6; color:#111; }

    /* Gemini API Key 卡片 */
    .apikey-card { border:1px solid #e5e7eb; border-radius:10px; padding:12px; margin:14px 0; background:#f9fafb; }
    .apikey-card h3 { margin:0 0 8px; font-size:16px; color:#374151; }
    .apikey-row { display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap; }
    #gemini-api-key { flex:1; min-width:280px; padding:8px 10px; border:1px solid #d1d5db; border-radius:6px; }
    .key-btn, #recognize-ai-btn { padding:8px 12px; border:1px solid #d1d5db; border-radius:6px; background:#fff; cursor:pointer; }
    .key-btn:hover, #recognize-ai-btn:hover { background:#f3f4f6; }
    #recognize-ai-btn.primary { background:#10b981; color:#fff; border-color:#10b981; }
    #gemini-status { font-size:12px; color:#6b7280; min-height:18px; }

    /* 新增的樣式區域 */
    /* 安全預編譯：單一來源，避免字串拼接遺失跳脫 */
    .chord-token-re {
      display: none;
    }
    .chord-line-re {
      display: none;
    }
  </style>
</head>
<body>
  <!-- 頁面標題與分頁導航 -->
  <header class="app-header">
    <h1 class="app-title">簡譜和弦轉換</h1>
    <nav class="tabs" role="tablist">
      <button class="tab-btn" role="tab" id="tab-upload" data-view="upload" aria-selected="true">讀取</button>
      <button class="tab-btn" role="tab" id="tab-recognition" data-view="recognition" aria-selected="false">辨識編輯</button>
      <button class="tab-btn" role="tab" id="tab-transpose" data-view="transpose" aria-selected="false">移調</button>
      <button class="tab-btn" role="tab" id="tab-export" data-view="export" aria-selected="false">匯出</button>
    </nav>
  </header>

  <!-- 工作區框架 -->
  <main class="workspace-frame">
    <!-- 讀取分頁 -->
    <section id="upload-section">
      <!-- 上傳區域 -->
      <div class="upload-area" id="drop-area">
        <input id="file-input" type="file" accept=".jpg,.jpeg,.png,.pdf" style="display: none;" />
        <div class="upload-icon">
          <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 16.5V6.5M12 6.5L7.5 11M12 6.5L16.5 11" stroke="#22c3ee" stroke-width="2" stroke-linecap="round"/>
            <path d="M3 15v4a2 2 0 002 2h14a2 2 0 002-2v-4" stroke="#22c3ee" stroke-width="2" stroke-linecap="round"/>
          </svg>
        </div>
        <p>拖曱檔案到這裡或點擊上傳</p>
        <p><small>支援格式：JPG, PNG, PDF</small></p>
      </div>
      
      <!-- 檔案資訊與預覽區域 (初始隱藏) -->
      <div class="file-preview-area hidden" id="file-preview-area">
        <div class="file-info">
          <span class="file-name" id="file-name">未選擇檔案</span>
          <span class="file-size" id="file-size"></span>
        </div>
        <div class="preview-container" id="file-preview-container">
          <!-- 預覽圖將由 JS 插入 -->
        </div>
      </div>
      
      <!-- Gemini AI 辨識區域 -->
      <div class="apikey-card" id="gemini-card">
        <h3>AI 辨識（Google Gemini）</h3>
        <div class="apikey-row">
          <input id="gemini-api-key" type="password" placeholder="輸入你的 Gemini API key（僅存於本機）" />
          <button id="save-gemini-key" class="key-btn">儲存金鑰</button>
          <button id="clear-gemini-key" class="key-btn">清除</button>
        </div>
        <div class="apikey-row">
          <label><input type="checkbox" id="use-gemini-ai" /> 啟用 AI 辨識</label>
          <button id="recognize-ai-btn" type="button" class="primary" disabled>使用 AI 辨識</button>
          <span id="gemini-status"></span>
        </div>
      </div>
    </section>

    <!-- 辨識編輯分頁 -->
    <section id="recognition-section" class="hidden">
      <div class="recognition-container">
        <!-- 左右對照區域 -->
        <div class="recognition-compare-area">
          <div class="original-image-container">
            <h3>原始圖片</h3>
            <div id="original-image" class="image-container"></div>
          </div>
          <div class="recognition-result-container">
            <h3>辨識結果 <span id="recognition-status">(待開始)</span></h3>
            <div id="text-editor-wrap">
              <div class="text-tools">
                <button id="copy-text" class="tool-btn">複製</button>
                <button id="clear-text" class="tool-btn">清空</button>
                <button id="apply-text" class="tool-btn primary">套用到匯出</button>
                <button id="show-log" class="tool-btn">顯示 Log</button>
              </div>
              <textarea id="text-editor" placeholder="辨識完成後會自動轉換為文字，您可直接編輯…"></textarea>
              <!-- Gemini API Log 顯示區域 -->
              <div id="gemini-log" class="hidden" style="margin-top: 10px; padding: 10px; background: #f5f5f5; border-radius: 4px; max-height: 200px; overflow-y: auto;">
                <h4 style="margin: 0 0 10px 0; color: #666;">Gemini API 回傳 Log：</h4>
                <pre id="gemini-log-content" style="margin: 0; font-size: 12px; color: #333; white-space: pre-wrap;"></pre>
              </div>
            </div>
          </div>
        </div>
        <!-- 底部：編輯工具面板 -->
        <div class="edit-panel"></div>
      </div>
      <div class="recognition-controls">
        <button id="recognize-again" class="action-btn secondary">重新辨識</button>
        <button id="to-transpose-btn" class="action-btn primary">下一步：移調</button>
      </div>
    </section>

    <!-- 移調分頁 -->
    <section id="transpose-section" class="hidden">
      <div class="text-tools" style="justify-content:flex-start; gap:12px;">
        <label>原調
          <select id="original-key">
            <option>C</option><option>C#</option><option>D</option><option>D#</option><option>E</option><option>F</option>
            <option>F#</option><option>G</option><option>G#</option><option>A</option><option>A#</option><option>B</option>
          </select>
        </label>
        <label>→ 目標
          <select id="target-key">
            <option>C</option><option>C#</option><option>D</option><option>D#</option><option>E</option><option>F</option>
            <option>F#</option><option>G</option><option>G#</option><option>A</option><option>A#</option><option>B</option>
          </select>
        </label>
        <button id="transpose-btn">套用移調</button>
      </div>
      <div id="transpose-editor-wrap" style="margin-top:8px; display:flex; flex-direction:column; min-height:200px;">
        <textarea id="transpose-editor" placeholder="這裡會自動帶入上一頁的文字譜，您可以在此進一步編輯或校正後再移調" style="flex:1 1 auto; min-height:0; width:100%; border:1px solid #e5e7eb; border-radius:8px; padding:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace; line-height:1.6; white-space:pre; overflow-y:auto;"></textarea>
      </div>
      <div id="transposed-result" style="margin-top:12px;"></div>
      <button id="to-export-btn" style="margin-top:15px;">下一步：匯出</button>
    </section>

    <!-- 匯出分頁 -->
    <section id="export-section" class="hidden">
      <div class="export-toolbar">
        <button id="download-png" class="export-btn">下載 PNG</button>
        <button id="download-pdf" class="export-btn primary">下載 PDF</button>
      </div>
      <div id="export-canvas-wrap">
        <pre id="export-preview">(待生成預覽)</pre>
      </div>
    </section>
    

    
  </main>

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
  <script src="https://docs.opencv.org/4.8.0/opencv.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/music-chord-parser@0.1.2/dist/music-chord-parser.min.js"></script>
  <!-- 匯出所需函式庫 -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <!-- 新增模組腳本（上傳 / 移調 / 匯出） -->
  <script src="public/js/upload-module.js"></script>
  <script src="public/js/transpose-module.js"></script>
  <script src="public/js/export-module.js"></script>
  <!-- AI 直接辨識模組（取代 OCR 強化處理） -->
  <script src="public/js/ai-direct-recognition.js"></script>
  <script type="module">
    import {
      buildPrompt,
      processGeminiText,
      formatGeminiResponse
    } from './public/js/ai-utils.js';

    // 將模組函式掛到全域，供下方非模組腳本使用
    window.formatGeminiResponse = formatGeminiResponse;
    //（可選）另外導出供除錯，不覆蓋既有全域同名函式
    window.__AIUtils__ = { buildPrompt, processGeminiText, formatGeminiResponse };

    // ========================================================================
    // 全域狀態管理
    // ========================================================================
    window.AppState = {
        preURL: null,
        tokens: [],
        currentTranspose: 0
    };

    // ========================================================================
    // DOM 元素參考
    // ========================================================================
    const elements = {
        fileInput: document.getElementById('file-input'),
        startBtn: document.getElementById('start-recognition-btn'),
        aiBtn: document.getElementById('recognize-ai-btn'),
        apiKeyInput: document.getElementById('gemini-api-key'),
        useAiCheckbox: document.getElementById('use-gemini-ai'),
        recognitionStatus: document.getElementById('recognition-status'),
        geminiStatus: document.getElementById('gemini-status'),
        originalImage: document.getElementById('original-image'),
        recognitionResult: document.getElementById('recognition-result'),
        textEditor: document.getElementById('text-editor'),
    };

    // ========================================================================
    // 事件監聽與 UI 更新
    // ========================================================================

    // 檔案選擇處理
    elements.fileInput.addEventListener('change', function() {
        const file = this.files[0];
        if (file) {
            const reader = new FileReader();
      reader.onload = function(e) {
        window.AppState.preURL = e.target.result;
        elements.originalImage.innerHTML = `<img src="${e.target.result}" alt="原始圖片">`;
                updateAIButtonState();
            };
            reader.readAsDataURL(file);
        } else {
            window.AppState.preURL = null;
            elements.originalImage.innerHTML = '';
            updateAIButtonState();
        }
    });

    // 更新 AI 按鈕狀態的邏輯
    function updateAIButtonState() {
        const hasFile = !!window.AppState.preURL;
        const hasKey = elements.apiKeyInput.value.trim().length > 0;
        const useAI = elements.useAiCheckbox.checked;
        elements.aiBtn.disabled = !(hasFile && hasKey && useAI);
    }

    elements.apiKeyInput.addEventListener('input', updateAIButtonState);
    elements.useAiCheckbox.addEventListener('change', updateAIButtonState);
    // 移除此段內建 AI 按鈕綁定（改由下方單一處理邏輯綁定，避免重複與未定義變數）
    // ...existing code...
  </script>
  <script>
// 防重入
(function (g, d) {
  if (g.__GeminiUIBootLoaded) return; g.__GeminiUIBootLoaded = true;

  // 1) 忽略 Pouch 404 錯誤，避免中斷
  function isPouchErr(e) {
    const n = (e && e.name) || '';
    const m = (e && (e.message || e.reason || '')) + '';
    const s = (e && e.status) || 0;
    return /pouch/i.test(n + m) || n === 'not_found' || s === 404;
  }
  g.addEventListener('error', ev => { const e = ev.error || ev.message || {}; if (isPouchErr(e)) { ev.preventDefault?.(); console.warn('[ignore] Pouch error', e); } });
  g.addEventListener('unhandledrejection', ev => { const r = ev.reason || {}; if (isPouchErr(r)) { ev.preventDefault?.(); console.warn('[ignore] Pouch rejection', r); } });

  // 2) 元件
  const $ = id => d.getElementById(id);
  const keyInput = $('gemini-api-key');
  const useCk    = $('use-gemini-ai');
  const aiBtn    = $('recognize-ai-btn');
  const recBtn   = $('recognize-btn');
  const fileIn   = $('file-input');
  const statusAI = $('gemini-status');
  const statusR  = $('recognition-status') || $('upload-status');
  const imgBox   = $('original-image') || $('recognition-result');
  const textArea = $('text-editor');

  // 自動高度調整：根據內容變化自適應高度，保留最小高度門檻
  function autoResizeTextEditor(el) {
    const ta = el || textArea;
    if (!ta) return;
    // 若採用 flex:1 等高填滿，就不以內容高度重設 height，避免破壞等高布局
    const style = g.getComputedStyle ? g.getComputedStyle(ta) : null;
    const isFlexFill = style && /flex\s*:/i.test(style.getPropertyValue('flex') || '');
    if (isFlexFill) {
      // 在等高模式下僅確保不低於 0，不需動態調整
      ta.style.minHeight = '0';
      return;
    }
    const min = 360; // 與 CSS min-height 對齊
    ta.style.height = 'auto';
    const next = Math.max(min, ta.scrollHeight + 2);
    ta.style.height = next + 'px';
  }
  // 導出到全域，供其他腳本存取
  g.autoResizeTextEditor = autoResizeTextEditor;

  // 3) 啟用邏輯
  function syncRecognizeBtn() {
    if (!fileIn || !recBtn) return;
    recBtn.disabled = !(fileIn.files && fileIn.files.length > 0);
  }
  function syncAIBtn() {
    if (!aiBtn) return;
    const hasKey = !!(keyInput && keyInput.value.trim());
    const enabled = (!!useCk ? useCk.checked : true) && hasKey;
    aiBtn.disabled = !enabled;
  }

  // 輸入時即時調整高度
  if (textArea && !textArea.__autoresize) {
    textArea.addEventListener('input', autoResizeTextEditor);
    textArea.__autoresize = true;
    // 初始化調整一次，避免空內容但高度太小
    d.addEventListener('DOMContentLoaded', autoResizeTextEditor, { once: true });
    // 若頁面已載入完成則直接調整
    if (d.readyState !== 'loading') autoResizeTextEditor();
  }

  // 4) 取得目前影像 URL（檔案/已有預覽/AppState）
  function currentImageURL() {
    if (fileIn && fileIn.files && fileIn.files[0]) {
      try { return URL.createObjectURL(fileIn.files[0]); } catch (_) {}
    }
    if (g.AppState && g.AppState.preURL) return g.AppState.preURL;
    const img = imgBox && imgBox.querySelector && imgBox.querySelector('img');
    if (img && img.src) return img.src;
    return '';
  }

  // 5) 後備顯示（當沒有 performRecognition）
    function fallbackPreview(url) {
    if (!imgBox || !url) return;
    imgBox.innerHTML = '';
    const img = new Image();
    img.src = url;
      // 保持原尺寸，由 CSS 規則控制
    imgBox.appendChild(img);
  }

  // 6) 點擊處理：開始辨識（沿用既有 recBtn）
  async function onRecognizeClick() {
    try {
      const url = currentImageURL();
      if (!url) { statusR && (statusR.textContent = '尚未選擇檔案'); return; }
      g.AppState = g.AppState || {}; g.AppState.preURL = url;
      if (typeof g.performRecognition === 'function') {
        statusR && (statusR.textContent = '開始辨識中...');
        await g.performRecognition(url);
        statusR && (statusR.textContent = '辨識完成');
        d.dispatchEvent(new CustomEvent('app:recognition-finished'));
      } else {
        fallbackPreview(url);
        statusR && (statusR.textContent = '(後備) 辨識完成');
        d.dispatchEvent(new CustomEvent('app:recognition-finished'));
      }
    } catch (e) {
      console.error('[recognize]', e);
      statusR && (statusR.textContent = '辨識錯誤：' + (e.message || e));
    }
  }

  // 7) 點擊處理：AI 辨識（Gemini）
  async function onAIClick() {
    try {
      const key = keyInput ? keyInput.value.trim() : '';
      if (!key) { statusAI && (statusAI.textContent = '請輸入 API key'); return; }
      const url = currentImageURL();
      if (!url) { statusAI && (statusAI.textContent = '請先選擇或載入影像'); return; }

      statusAI && (statusAI.textContent = 'AI 辨識執行中...');
      statusR && (statusR.textContent = '開始 AI 辨識...');
      g.AppState = g.AppState || {}; g.AppState.preURL = url;

      // 顯示原圖
      fallbackPreview(url);

      try {
        // 呼叫真正的 Gemini API
        const result = await callGeminiAPI(key, url);
        
        // 記錄 API 回傳結果
        if (typeof g.setGeminiLog === 'function') {
          g.setGeminiLog({
            timestamp: new Date().toISOString(),
            request: {
              apiKey: key.substring(0, 10) + '...',
              imageUrl: url.substring(0, 50) + '...',
              model: 'gemini-2.5-flash'
            },
            response: result
          });
        }

        // 解析 API 回應並轉換為 tokens
        const tokens = parseGeminiResponse(result);
        g.AppState.tokens = tokens;

        // 更新文字編輯器
        if (typeof g.updateTextEditor === 'function') {
          g.updateTextEditor(tokens);
          autoResizeTextEditor();
        } else {
          autoResizeTextEditor();
        }

        statusR && (statusR.textContent = `AI 辨識完成，找到 ${tokens.length} 個項目`);
        statusAI && (statusAI.textContent = 'AI 辨識完成');
        
      } catch (apiError) {
        console.error('[Gemini API]', apiError);
        
        // 記錄錯誤
        if (typeof g.setGeminiLog === 'function') {
          g.setGeminiLog({
            timestamp: new Date().toISOString(),
            request: {
              apiKey: key.substring(0, 10) + '...',
              imageUrl: url.substring(0, 50) + '...',
              model: 'gemini-1.5-flash'
            },
            error: {
              message: apiError.message,
              stack: apiError.stack
            }
          });
        }

        // API 失敗時使用後備方案
        statusAI && (statusAI.textContent = 'API 呼叫失敗，使用後備辨識');
        g.AppState.tokens = [
          { kind: 'chord', x: 20, y: 20, w: 40, h: 20, text: 'C' },
          { kind: 'chord', x: 80, y: 20, w: 40, h: 20, text: 'F' },
          { kind: 'chord', x: 140, y: 20, w: 40, h: 20, text: 'G' },
          { kind: 'lyric', x: 20, y: 50, w: 160, h: 20, text: '後備辨識結果' },
        ];
        
        if (typeof g.updateTextEditor === 'function') {
          g.updateTextEditor(g.AppState.tokens);
          autoResizeTextEditor();
        } else {
          autoResizeTextEditor();
        }
        statusR && (statusR.textContent = '(後備) 辨識完成');
      }

      d.dispatchEvent(new CustomEvent('app:recognition-finished'));
    } catch (e) {
      console.error('[gemini]', e);
      statusAI && (statusAI.textContent = 'AI 辨識錯誤：' + (e.message || e));
    }
  }

  // Gemini API 呼叫函式
  async function callGeminiAPI(apiKey, imageUrl) {
    // 將 data URL 轉換為 base64
    const base64Data = imageUrl.split(',')[1];
    
    const payload = {
      contents: [{
        parts: [{
          text: g.buildPrompt()
        }, {
          inline_data: {
            mime_type: "image/png",
            data: base64Data
          }
        }]
      }]
    };

    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(payload)
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(`Gemini API 錯誤: ${response.status} - ${errorData.error?.message || response.statusText}`);
    }

    const data = await response.json();
    return data;
  }

  // 解析 Gemini 回應
  function parseGeminiResponse(response) {
    try {
      const text = response.candidates?.[0]?.content?.parts?.[0]?.text || '';
      console.log('[Gemini Response Text]', text);
      
      // 嘗試從回應中提取和弦和歌詞
      const lines = text.split('\n').filter(line => line.trim());
      const tokens = [];
      let yPos = 20;
      
      lines.forEach((line, index) => {
        const trimmedLine = line.trim();
        if (!trimmedLine) return;
        
        // 更全面的和弦辨識模式，包括中文樂譜常見的格式
        const chordPatterns = [
          // 基本和弦模式：A, Am, A7, Amaj7, A#, Bb/D 等
          /\|([A-G][#b]?(?:maj|min|m|sus|dim|aug|add|[0-9]+)*(?:\/[A-G][#b]?)?)[\s]*\|/g,
          // 簡單和弦模式（無縱線）
          /\b([A-G][#b]?(?:maj|min|m|sus|dim|aug|add|[0-9]+)*(?:\/[A-G][#b]?)?)\b/g
        ];
        
        let isChordLine = false;
        let chords = [];
        
        // 嘗試用不同的模式匹配和弦
        for (const pattern of chordPatterns) {
          const matches = trimmedLine.match(pattern);
          if (matches && matches.length > 0) {
            chords = matches.map(match => match.replace(/[\|\s]/g, '').trim()).filter(c => c);
            if (chords.length > 0) {
              isChordLine = true;
              break;
            }
          }
        }
        
        // 判斷是否為和弦行（包含縱線或多個大寫字母）
        if (!isChordLine) {
          isChordLine = /\|.*\|/.test(trimmedLine) || 
                       (trimmedLine.match(/[A-G]/g) || []).length >= 2;
        }
        
        if (isChordLine && chords.length > 0) {
          // 這行包含和弦
          let xPos = 20;
          chords.forEach(chord => {
            if (chord && chord.length > 0) {
              tokens.push({
                kind: 'chord',
                x: xPos,
                y: yPos,
                w: Math.max(30, chord.length * 12),
                h: 20,
                text: chord
              });
              xPos += Math.max(40, chord.length * 15);
            }
          });
        } else if (trimmedLine.length > 0) {
          // 這行是歌詞或其他文字
          tokens.push({
            kind: 'lyric',
            x: 20,
            y: yPos,
            w: Math.max(100, trimmedLine.length * 10),
            h: 20,
            text: trimmedLine
          });
        }
        yPos += 35;
      });
      
      return tokens.length > 0 ? tokens : [
        { kind: 'lyric', x: 20, y: 20, w: 200, h: 20, text: '無法解析 Gemini 回應\n\n原始回應：' + text.substring(0, 100) + '...' }
      ];
      
    } catch (e) {
      console.error('[Parse Gemini Response]', e);
      return [
        { kind: 'lyric', x: 20, y: 20, w: 200, h: 20, text: '解析回應時發生錯誤：' + e.message }
      ];
    }
  }

  // 8) 綁定事件
  function wire() {
    if (fileIn)  fileIn.addEventListener('change', () => { syncRecognizeBtn(); /* 選檔後預存 URL */ g.AppState = g.AppState || {}; g.AppState.preURL = currentImageURL(); });
    if (recBtn && !recBtn.__wired) { recBtn.addEventListener('click', onRecognizeClick); recBtn.__wired = true; }
    if (keyInput) keyInput.addEventListener('input', syncAIBtn);
    if (useCk)    useCk.addEventListener('change', syncAIBtn);
    if (aiBtn && !aiBtn.__wired) { aiBtn.addEventListener('click', onAIClick); aiBtn.__wired = true; }

    // 分頁切換：定義並導出 switchView
    if (typeof g.switchView !== 'function') {
      g.switchView = function(view){
        const views = {
          upload: 'upload-section',
          recognition: 'recognition-section',
          transpose: 'transpose-section',
          export: 'export-section'
        };
        const tabs = {
          upload: d.getElementById('tab-upload'),
          recognition: d.getElementById('tab-recognition'),
          transpose: d.getElementById('tab-transpose'),
          export: d.getElementById('tab-export')
        };
        // 切換區塊顯示
        Object.values(views).forEach(id => { const el = d.getElementById(id); el && el.classList.add('hidden'); });
        const targetId = views[view];
        const target = targetId ? d.getElementById(targetId) : null;
        if (target) target.classList.remove('hidden');
        // 切換 tab 樣式
        Object.values(tabs).forEach(tb => { if (tb) tb.setAttribute('aria-selected', 'false'); });
        const activeTab = tabs[view];
        if (activeTab) activeTab.setAttribute('aria-selected', 'true');

        // 進入移調頁時，帶入辨識結果的文字
        if (view === 'transpose') {
          try {
            const src = d.getElementById('text-editor');
            const dst = d.getElementById('transpose-editor');
            if (src && dst && !dst.__filledOnce) {
              dst.value = src.value || '';
              dst.__filledOnce = true; // 初次帶入，之後使用者可編輯不被覆蓋
              g.autoResizeTextEditor?.(dst);
            }
          } catch(_) {}
        }
        // 進入匯出頁時，帶入移調後或辨識後的文字
        if (view === 'export') {
          try {
            const dst = d.getElementById('export-preview');
            const fromTranspose = d.getElementById('transpose-editor');
            const fromText = d.getElementById('text-editor');
            let srcText = fromTranspose?.value || fromText?.value || '';
            // 移除最外層 ``` 包裝（若存在）
            srcText = srcText.replace(/^```[\s\S]*?\n/,'').replace(/\n```\s*$/,'');
            if (dst) dst.textContent = srcText || '(沒有可匯出的內容)';
          } catch(_) {}
        }
        return view;
      };
    }

    // Tab 點擊導覽
    const tabBtns = d.querySelectorAll('.tab-btn[data-view]');
    tabBtns.forEach(btn => {
      if (!btn.__wired) {
        btn.addEventListener('click', () => { const v = btn.getAttribute('data-view'); if (v) g.switchView(v); });
        btn.__wired = true;
      }
    });

    // 下一步按鈕：辨識 → 移調、移調 → 匯出
    const toTranspose = d.getElementById('to-transpose-btn');
    if (toTranspose && !toTranspose.__wired) {
      toTranspose.addEventListener('click', () => {
        // 帶入後再切換頁面
        try {
          const src = d.getElementById('text-editor');
          const dst = d.getElementById('transpose-editor');
          if (src && dst) {
            dst.value = src.value || '';
            g.autoResizeTextEditor?.(dst);
          }
        } catch(_) {}
        g.switchView('transpose');
      });
      toTranspose.__wired = true;
    }
    const toExport = d.getElementById('to-export-btn');
    if (toExport && !toExport.__wired) {
      toExport.addEventListener('click', () => {
        // 切頁前先把第三步的內容帶到預覽
        try {
          const dst = d.getElementById('export-preview');
          const fromTranspose = d.getElementById('transpose-editor');
          const fromText = d.getElementById('text-editor');
          let srcText = fromTranspose?.value || fromText?.value || '';
          srcText = srcText.replace(/^```[\s\S]*?\n/,'').replace(/\n```\s*$/,'');
          if (dst) dst.textContent = srcText || '(沒有可匯出的內容)';
        } catch(_) {}
        g.switchView('export');
      });
      toExport.__wired = true;
    }

    // 辨識完成後，自動切到「辨識編輯」分頁，確保可見，並更新文字編輯器
    d.addEventListener('app:recognition-finished', () => { 
      g.switchView('recognition'); 
      // 確保文字編輯器顯示最新的辨識結果
      if (typeof g.updateTextEditor === 'function' && g.AppState?.tokens) {
        g.updateTextEditor(g.AppState.tokens);
      }
      autoResizeTextEditor();
    });

    syncRecognizeBtn(); syncAIBtn();
  }
  if (d.readyState === 'loading') d.addEventListener('DOMContentLoaded', wire, { once: true }); else wire();

  // 9) buildPrompt 函式（為 Gemini API 提供詳細提示）
  if (typeof g.buildPrompt !== 'function') {
    g.buildPrompt = function () {
      return `你是一個專業的音樂譜辨識專家。請仔細辨識這張中文歌譜圖片中的所有內容。

**辨識規則：**
1. 辨識所有的和弦符號（通常在歌詞上方，如：F, C, Dm7, Bb2, G#等）
2. 辨識所有的中文歌詞
3. 請按照從上到下、從左到右的順序讀取

**輸出格式：**
直接輸出每一行的內容，和弦和歌詞各自一行。

**範例：**
|F  |C  |Dm7 /C |Bb2 |
在你的院宇中歌唱
|F  |C  |Dm7    |Bb  |
讚美你的聖名

**重要：**
- 如果看到类似 |F2 |  |或 |Csus| 的格式，請完整保留豎線|
- 不要忽略任何歌詞或和弦
- 保持原有的行的結構和格式
- 直接輸出，不要加任何解釋或說明`;
    };
  }
})(window, document);
</script>
<!-- OCR 改善腳本已移除，現在主要使用 Gemini API 進行辨識 -->
<script src="public/js/recognition-skip-ocr-when-tokens.js"></script>
<script>
(function (g, d) {
  if (g.__GeminiAPIFixLoaded) return;
  g.__GeminiAPIFixLoaded = true;

  const log = (...a) => console.log('[GeminiFix]', ...a);
  const warn = (...a) => console.warn('[GeminiFix]', ...a);
  const err = (...a) => console.error('[GeminiFix]', ...a);

  // 將任意來源轉成 { mimeType, base64 }
  async function resolveImageToBase64(src) {
    try {
      // 1) data:URL
      if (typeof src === 'string' && src.startsWith('data:')) {
        const m = src.match(/^data:([^;]+);base64,(.*)$/);
        if (!m || !m[2]) throw new Error('data:URL 內容為空');
        return { mimeType: m[1] || 'image/png', base64: m[2] };
      }

      // 2) blob: URL 或 http(s) URL
      if (typeof src === 'string' && (src.startsWith('blob:') || /^https?:/.test(src))) {
        const resp = await fetch(src);
        if (!resp.ok) throw new Error(`fetch 失敗: ${resp.status}`);
        const blob = await resp.blob();
        return blobToResolvedImage(blob);
      }

      // 3) Blob/File
      if (src instanceof Blob) {
        const { mimeType, base64 } = await blobToResolvedImage(src);
        return { mimeType, base64 };
      }

      // 4) 後備：若沒提供或格式不符，嘗試使用 AppState.preURL
      if (g.AppState?.preURL) {
        return await resolveImageToBase64(g.AppState.preURL);
      }

      throw new Error('不支援的影像來源，且找不到 AppState.preURL');
    } catch (e) {
      err('resolveImageToBase64 失敗', e);
      throw e;
    }
  }

  function blobToResolvedImage(blob) {
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onerror = () => reject(new Error('FileReader 讀取失敗'));
      fr.onloadend = () => {
        const result = fr.result;
        if (typeof result !== 'string') return reject(new Error('FileReader 結果無效'));
        const m = result.match(/^data:([^;]+);base64,(.*)$/);
        if (!m || !m[2]) return reject(new Error('無法自 data:URL 提取 base64'));
        resolve({ mimeType: m[1] || (blob.type || 'image/png'), base64: m[2] });
      };
      fr.readAsDataURL(blob);
    });
  }

  async function callGeminiAPIFixed(imageUrlOrBlob, apiKey, prompt) {
    const startedAt = Date.now();
    try {
      // 統一從來源取得 base64 與正確的 mime
      const source = g.AppState?.preURL || imageUrlOrBlob;
      const { mimeType, base64 } = await resolveImageToBase64(source);
      if (!base64) throw new Error('inlineData base64 為空');

      const body = {
        contents: [{
          parts: [
            { text: prompt || (typeof g.buildPrompt === 'function' ? g.buildPrompt() : '請萃取和弦與歌詞') },
            { inlineData: {
                mimeType,
                data: base64
              }
            }
          ]
        }],
        generationConfig: { temperature: 0.1, topK: 32, topP: 1, maxOutputTokens: 4096 }
      };

      const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;
      const res = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });

      if (!res.ok) {
        const text = await res.text().catch(() => '');
        throw new Error(`Gemini API 錯誤: ${res.status} - ${text || '未知錯誤'}`);
      }

      const json = await res.json();
      log('API 成功，用時(ms):', Date.now() - startedAt);
      // 取第一段文字
      const text = json?.candidates?.[0]?.content?.parts?.map(p => p.text).filter(Boolean).join('\n');
      if (!text) warn('回傳沒有文字部分，原樣回傳 JSON');
      return text || JSON.stringify(json);
    } catch (e) {
      const errorLog = {
        timestamp: new Date().toISOString(),
        request: {
          apiKey: apiKey ? String(apiKey).slice(0, 8) + '...' : '未提供',
          imageUrl: typeof imageUrlOrBlob === 'string' ? imageUrlOrBlob : (g.AppState?.preURL ? '[AppState.preURL]' : '[Blob]'),
          model: 'gemini-1.5-flash'
        },
        error: { message: e.message, stack: e.stack }
      };
      err('Gemini API 回傳 Log：\n' + JSON.stringify(errorLog, null, 2));
      throw e;
    }
  }

 

  // 覆寫全域呼叫
  const prev = g.callGeminiAPI;
  g.callGeminiAPI = callGeminiAPIFixed;
  log('修正載入完成，原函式型別:', typeof prev);
})(window, document);
</script>
<script>
  // 確保所有程式碼在一個立即執行的函式 (IIFE) 中，避免汙染全域範圍
  (function (g, d) {
    // 防止腳本重複載入
    if (g.__CHORD_TRANSPOSE_APP_LOADED__) return;
    g.__CHORD_TRANSPOSE_APP_LOADED__ = true;

    console.log('[App] 腳本啟動');

    // 全域狀態
    g.AppState = g.AppState || {
      rawURL: null, // 原始檔案的 URL
      preURL: null, // 預處理後的圖片 URL (此處等於 rawURL)
      tokens: [],   // 辨識出的 token
      geminiLog: null // Gemini API 的日誌
    };

    // DOM 元素快取
    const $ = id => d.getElementById(id);
    const elements = {
      fileInput: $('file-input'),
      apiKeyInput: $('gemini-api-key'),
      useAiCheckbox: $('use-gemini-ai'),
      aiBtn: $('recognize-ai-btn'),
      recBtn: $('recognize-btn'),
      geminiStatus: $('gemini-status'),
      recognitionStatus: $('recognition-status'),
      originalImage: $('original-image'),
      recognitionResult: $('recognition-result'),
      textEditor: $('text-editor'),
      showLogBtn: $('show-log'),
      geminiLogDiv: $('gemini-log'),
      geminiLogContent: $('gemini-log-content')
    };

    // 讓移調頁可操作的元素
    const transposeEditor = d.getElementById('transpose-editor');
    const originalKeySel = d.getElementById('original-key');
    const targetKeySel   = d.getElementById('target-key');
    const transposeBtn   = d.getElementById('transpose-btn');
    const transposeOut   = d.getElementById('transposed-result');

    /**
     * 更新 AI 辨識按鈕的狀態
     */
    function syncAIBtn() {
      if (!elements.aiBtn) return;
      const hasKey = !!(elements.apiKeyInput && elements.apiKeyInput.value.trim());
      const useAI = !!(elements.useAiCheckbox && elements.useAiCheckbox.checked);
      const hasFile = !!(elements.fileInput && elements.fileInput.files.length > 0);
      elements.aiBtn.disabled = !(useAI && hasKey && hasFile);
    }

    /**
     * 取得目前要辨識的圖片 URL
     */
    function getCurrentImageURL() {
      if (g.AppState.preURL) return g.AppState.preURL;
      if (elements.fileInput && elements.fileInput.files[0]) {
        try {
          const url = URL.createObjectURL(elements.fileInput.files[0]);
          g.AppState.preURL = url; // 快取 URL
          return url;
        } catch (e) {
          console.error('無法建立 Object URL', e);
          return null;
        }
      }
      return null;
    }

    /**
     * 將 Blob 或 data:URL 轉換為 Base64 字串
     */
    function blobToResolvedImage(blob) {
      return new Promise((resolve, reject) => {
        if (!blob || blob.size === 0) {
          return reject(new Error('Blob 物件為空'));
        }
        const reader = new FileReader();
        reader.onerror = () => reject(new Error('FileReader 讀取時發生錯誤'));
        reader.onloadend = () => {
          const result = reader.result;
          if (typeof result !== 'string') {
            return reject(new Error('FileReader 讀取結果無效'));
          }
          const match = result.match(/^data:([^;]+);base64,(.*)$/);
          if (!match || !match[2]) {
            return reject(new Error('無法從 data:URL 解析 base64 資料'));
          }
          resolve({ mimeType: match[1] || blob.type, base64: match[2] });
        };
        reader.readAsDataURL(blob);
      });
    }

    /**
     * 解析各種影像來源，最終回傳 { mimeType, base64 }
     */
    async function resolveImageSource(src) {
      if (typeof src !== 'string' || !src) {
        throw new Error('無效的影像來源');
      }
      if (src.startsWith('data:')) {
        const match = src.match(/^data:([^;]+);base64,(.*)$/);
        if (!match || !match[2]) throw new Error('無效的 data:URL 格式');
        return { mimeType: match[1], base64: match[2] };
      }
      if (src.startsWith('blob:') || src.startsWith('http')) {
        const response = await fetch(src);
        if (!response.ok) throw new Error(`無法擷取資源: ${response.status}`);
        const blob = await response.blob();
        return blobToResolvedImage(blob);
      }
      throw new Error('不支援的影像來源格式');
    }

    /**
     * 建立傳送給 Gemini API 的提示
     */
    function buildPrompt() {
      return `請你扮演一位精準的樂譜文字辨識專家。你的任務是將我上傳的樂譜圖片，轉換為排版精確、易于複製的純文字格式。

請嚴格遵守以下排版規則：

完整標題資訊：擷取並放在最上方，包含歌曲名稱、調性 (Key) 和速度 (BPM)。

依照所提供的譜，保留歌曲結構：清楚標示出所有本來譜中所有段落標題，例如：Intro (前奏)、Verse (主歌)、Pre-Chorus (導歌)、Chorus (副歌)、Bridge (橋段)、Outro (尾奏) 等。

和弦在上，歌詞在下：和弦必須在歌詞的正上方，並且分成兩行獨立呈現。

精準對位：將每個歌詞（或單字）精確地對齊在上方的和弦，使用空格來調整歌詞位置，這是最重要的要求。

保留所有音樂符號：完整保留圖片中的所有音樂符號，特別是：

小節線：|

和弦變化：例如 Dm7, Csus4, G/B 等複雜和弦，可以寫成Dm, Csus4, G/B就好，不要加上<sup>，例如D<sup>m7</sup>。每一格和弦都要用豎線 | 包起來。每個和弦之間至少保留一個空格。每小節的長度為8個空格。遇到小節間沒有填寫任何和弦的情況，請用 |    | 來表示。  

重複記號：如果有 𝄆 𝄇，記得取代小節線

歌詞的要求：保留所有標點符號和空格，確保歌詞的完整性，但不需要小節線，這很重要。

使用等寬字體格式：請將最終結果放入一個程式碼區塊 (Code Block) 中，以確保對齊不會因字體而跑掉。

格式範例如下：

[歌曲名稱]

[段落標題]
|[和弦]  |[和弦]      |[和弦]
 [歌詞]    [歌詞]      [歌詞]


正確範例（示意，注意對齊與空小節）：
"chords": "|F2      |Csus       |Dm7  /C     |Bb2      |"
"lyrics": " 奔 向 祢 的 殿 中 讓 讚 美   湧 流 在 我 心 頭"
`;
    }

    /**
     * 呼叫 Gemini API
     */
    async function callGeminiAPI(imageUrl, apiKey, prompt) {
      console.log('[API] 準備解析影像來源...');
      const { mimeType, base64 } = await resolveImageSource(imageUrl);
      console.log('[API] mimeType=', mimeType, 'base64Len=', base64.length);
      if (base64.length < 50) throw new Error('影像 base64 長度異常，可能讀取失敗');

      const body = {
        contents: [{
          parts: [
            { text: prompt },
            { inlineData: { mimeType, data: base64 } }
          ]
        }],
        generationConfig: { temperature: 0.1, maxOutputTokens: 4096 }
      };
      console.log('[API] 請求內容 (截斷):', JSON.stringify(body).slice(0, 180) + '...');

      const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;
      const resp = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify(body)
      });
      if (!resp.ok) {
        const txt=await resp.text().catch(()=> '');
        throw new Error(`Gemini API 錯誤 ${resp.status}: ${txt}`);
      }
      const json=await resp.json();
      const text=json?.candidates?.[0]?.content?.parts?.map(p=>p.text).filter(Boolean).join('\n')||'';
      console.log('[API] 回傳文字長度=', text.length);
      return text || JSON.stringify(json);
    }

    /**
     * 解析 Gemini 回傳的純文字 (這部分是之前解析失敗的地方)
     */
    function parseGeminiResponseToTokens(responseText) {
        // 這個解析器很基本，所以可能會失敗，但我們保留它來重現之前的狀態
        console.log('[Parser] 嘗試解析純文字:', responseText);
        const tokens = [{
            kind: 'lyric',
            text: `無法解析 Gemini 回應\n\n原始回應：\n${responseText}`,
            x: 10, y: 10, w: 400, h: 100
        }];
        // 即使解析失敗，我們也回傳一個 token，讓 UI 顯示錯誤訊息
        return tokens;
    }

    /**
     * 渲染 Tokens 到畫面上
     */
    function renderTokens(tokens) {
        if (!elements.recognitionResult) return;
        elements.recognitionResult.innerHTML = '';
        (tokens || []).forEach(token => {
            const el = document.createElement('div');
            el.className = `tag ${token.kind}`;
            el.textContent = token.text;
            el.style.cssText = `position: absolute; left: ${token.x}px; top: ${token.y}px; width: ${token.w}px; height: ${token.h}px;`;
            elements.recognitionResult.appendChild(el);
        });
        // 同時更新文字編輯器
        if (elements.textEditor) {
            elements.textEditor.value = (tokens || []).map(t => t.text).join('\n');
      // 內容更新後調整高度
      try { if (typeof window.autoResizeTextEditor === 'function') window.autoResizeTextEditor(); } catch(_) {}
        }
    }

    // --- 事件綁定 ---

    // 檔案輸入
    elements.fileInput?.addEventListener('change', () => {
      g.AppState.preURL = null; // 清除舊的 URL
      const url = getCurrentImageURL();
      if (url && elements.originalImage) {
        elements.originalImage.innerHTML = `<img src="${url}" style="max-width:100%; height:auto;">`;
      }
      syncAIBtn();
    });

    // 匯出 PNG
    (function bindExporters(){
      const pngBtn = d.getElementById('download-png');
      const pdfBtn = d.getElementById('download-pdf');
      const preview = d.getElementById('export-preview');
      const wrap = d.getElementById('export-canvas-wrap');
      if (pngBtn && !pngBtn.__wired) {
        pngBtn.addEventListener('click', async () => {
          try {
            const node = wrap || preview;
            const canvas = await html2canvas(node, { scale: 2, backgroundColor: '#ffffff' });
            const data = canvas.toDataURL('image/png');
            const a = d.createElement('a');
            a.href = data; a.download = 'chords.png'; a.click();
          } catch(e) { console.error('PNG 匯出失敗', e); }
        });
        pngBtn.__wired = true;
      }
      if (pdfBtn && !pdfBtn.__wired) {
        pdfBtn.addEventListener('click', async () => {
          try {
            const node = wrap || preview;
            const canvas = await html2canvas(node, { scale: 2, backgroundColor: '#ffffff' });
            const imgData = canvas.toDataURL('image/png');
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF({ unit: 'pt', format: 'a4' });
            const pageWidth = pdf.internal.pageSize.getWidth();
            const pageHeight = pdf.internal.pageSize.getHeight();

            // 將圖片寬度等比縮放到頁面寬（保留邊距）
            const margin = 24;
            const imgWidth = pageWidth - margin*2;
            const imgHeight = canvas.height * (imgWidth / canvas.width);

            let y = margin;
            let remaining = imgHeight;
            const sliceHeight = pageHeight - margin*2;

            // 單頁或多頁
            if (imgHeight <= sliceHeight) {
              pdf.addImage(imgData, 'PNG', margin, y, imgWidth, imgHeight);
            } else {
              // 多頁切片：透過 canvas 裁切輸出
              let position = 0;
              while (remaining > 0) {
                const pageCanvas = d.createElement('canvas');
                pageCanvas.width = canvas.width;
                const pageSlicePx = Math.min(canvas.height - position, Math.floor(sliceHeight * (canvas.width / imgWidth)));
                pageCanvas.height = pageSlicePx;
                const ctx = pageCanvas.getContext('2d');
                ctx.drawImage(canvas, 0, position, canvas.width, pageSlicePx, 0, 0, canvas.width, pageSlicePx);
                const pageImg = pageCanvas.toDataURL('image/png');
                if (position>0) pdf.addPage();
                pdf.addImage(pageImg, 'PNG', margin, margin, imgWidth, pageSlicePx * (imgWidth / canvas.width));
                position += pageSlicePx;
                remaining -= pageSlicePx * (imgWidth / canvas.width);
              }
            }
            pdf.save('chords.pdf');
          } catch(e) { console.error('PDF 匯出失敗', e); }
        });
        pdfBtn.__wired = true;
      }
    })();

    // 將 Gemini 回傳（可能是 JSON 或純文字）格式化為顯示用文字：
    // - 和弦行：保留豎線 |，移除 [F] 這類方括號
    // - 歌詞行：移除所有豎線 | 以及方括號和弦，其他空白保留
    function formatGeminiDisplay(raw) {
      // 使用全域掛載的 formatGeminiResponse；若不存在則原樣回傳字串
      return (typeof window.formatGeminiResponse === 'function')
        ? window.formatGeminiResponse(raw)
        : String(raw ?? '');
    }

    // AI 辨識按鈕（避免重複綁定）
    if (elements.aiBtn && elements.aiBtn.__wired) {
      // 已由前一段程式碼綁定，避免重複
    } else if (elements.aiBtn) {
      elements.aiBtn.__wired = true;
      elements.aiBtn.addEventListener('click', async () => {
      const apiKey = elements.apiKeyInput?.value.trim();
      const imageUrl = getCurrentImageURL();

      if (!apiKey) {
        elements.geminiStatus.textContent = '請輸入 API 金鑰';
        return;
      }
      if (!imageUrl) {
        elements.geminiStatus.textContent = '請先選擇一個影像檔案';
        return;
      }

      elements.geminiStatus.textContent = 'AI 辨識執行中...';
      try {
        const responseText = await callGeminiAPI(imageUrl, apiKey, buildPrompt());
        console.log('[AI] Gemini 原始回傳:', responseText);
        
        const tokens = parseGeminiResponseToTokens(responseText);
        g.AppState.tokens = tokens;
        
        // 寫入文字編輯器（歌詞不包含 |，和弦保留 |）
        if (elements.textEditor) {
          const display = formatGeminiDisplay(responseText);
          elements.textEditor.value = display;
          try { if (typeof window.autoResizeTextEditor === 'function') window.autoResizeTextEditor(); } catch(_) {}
        }

        renderTokens(tokens);
        elements.geminiStatus.textContent = 'AI 辨識完成';
        
        // 成功後切換到「辨識編輯」分頁
        if (typeof g.switchView === 'function') {
          g.switchView('recognition');
        } else if (typeof window.switchView === 'function') {
          window.switchView('recognition');
        }
        
      } catch (error) {
        console.error('[AI] 辨識流程失敗:', error);
        elements.geminiStatus.textContent = `錯誤: ${error.message}`;
        renderTokens([{ kind: 'error', text: `辨識失敗：${error.message}`, x:10, y:10, w:400, h:50 }]);
        try { if (typeof window.autoResizeTextEditor === 'function') window.autoResizeTextEditor(); } catch(_) {}
      }
    });
    }

    // 顯示 Log 按鈕
    elements.showLogBtn?.addEventListener('click', () => {
        if (!elements.geminiLogDiv || !elements.geminiLogContent) return;

        if (elements.geminiLogDiv.classList.toggle('hidden')) {
            return; // 如果是隱藏，就直接結束
        }

        if (g.AppState.geminiLog) {
            elements.geminiLogContent.textContent = JSON.stringify(g.AppState.geminiLog, null, 2);
        } else {
            elements.geminiLogContent.textContent = '尚無 Gemini API 的日誌紀錄。';
        }
    });

    // --- 轉調相關 ---
    function transposeChordText(ch, fromKey, toKey) {
      try {
        if (!ch) return ch;
        // 使用 TransposeModule 若有載入
        if (g.TransposeModule?.transposeChord) return g.TransposeModule.transposeChord(ch, fromKey, toKey);
        return ch;
      } catch { return ch; }
    }

    function isChordTokenLike(token) {
      return /^[A-G][#b]?(?:maj|min|m|sus|dim|aug|add|[0-9]+)*(?:\/[A-G][#b]?)?$/.test(token);
    }

    function transposePlainText(content, fromKey, toKey) {
      const lines = String(content||'').split('\n');
      return lines.map(line => {
        // 判定為和弦行：包含豎線 | 或多個可能的和弦 token
        const looksChordLine = /\|/.test(line) || (line.match(/[A-G]/g)||[]).length >= 2;
        if (!looksChordLine) return line; // 歌詞或其他行不處理

        // 逐個 token 轉調，保留原有空白與豎線
        return line.replace(/([A-G][#b]?(?:maj|min|m|sus|dim|aug|add|[0-9]+)*(?:\/[A-G][#b]?)?)/g, (m) => {
          if (!isChordTokenLike(m)) return m;
          return transposeChordText(m, fromKey, toKey);
        });
      }).join('\n');
    }

    if (transposeBtn && !transposeBtn.__wired) {
      transposeBtn.addEventListener('click', () => {
        const fromKey = originalKeySel?.value || 'C';
        const toKey   = targetKeySel?.value || 'C';
        const input   = transposeEditor?.value ?? elements.textEditor?.value ?? '';
        const outText = transposePlainText(input, fromKey, toKey);
        if (transposeOut) transposeOut.textContent = outText;
        if (transposeEditor) transposeEditor.value = outText;
        g.autoResizeTextEditor?.(transposeEditor);
      });
      transposeBtn.__wired = true;
    }

    // 初始化按鈕狀態
    syncAIBtn();
    console.log('[App] 初始化完成');

  })(window, document);
</script>
<script>
// 自動隱藏底部 Log 面板（不影響其它功能）
(function hideBottomLogs() {
  const candidates = [
    '#gemini-log', '#ai-log', '#recognition-log', '#recognize-log',
    '.log-panel', '.api-log', '.recognition-log', '.gemini-log',
    '[data-role="log"]', '#gemini-api-log', '#gemini-log-panel'
  ];

  // 隱藏已知的 Log 容器
  candidates.forEach(sel => {
    document.querySelectorAll(sel).forEach(el => {
      el.style.display = 'none';
      el.setAttribute('data-hidden-by', 'hide-logs');
    });
  });

  // 針對可能以 ``` 顯示的 Log/原始輸出做防護性隱藏
  const maybeLogs = document.querySelectorAll('pre, textarea, .code, .output');
  maybeLogs.forEach(el => {
    const text = (el.value ?? el.textContent ?? '').trim();
    if (!text) return;
    const looksLikeLog =
      /^```/.test(text) || /API.*Log/i.test(text) || /辨識\s*Log/i.test(text);
    if (looksLikeLog && (el.offsetHeight > 120 || text.length > 200)) {
      el.style.display = 'none';
      el.setAttribute('data-hidden-by', 'hide-logs');
    }
  });
})();
</script>
