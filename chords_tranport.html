<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8" />
  <title>簡譜和弦轉換</title>
  <style>
    body { 
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", Arial, sans-serif; 
      background-color: #f9f9f9;
      margin: 0;
      padding: 20px;
      color: #333;
    }
    .hidden { display: none; }
    
    /* 標題樣式 */
    .app-header {
      text-align: center;
      margin-bottom: 20px;
    }
    .app-title {
      font-size: 36px;
      font-weight: bold;
      color: #0891b2;
      margin-bottom: 20px;
    }
    
    /* 分頁按鈕樣式 */
    .tabs {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-bottom: 25px;
    }
    .tab-btn {
      min-width: 120px;
      padding: 12px 20px;
      border: 2px solid #22c3ee;
      border-radius: 25px;
      background: white;
      color: #22c3ee;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      text-align: center;
      transition: all 0.2s ease;
    }
    .tab-btn:hover {
      background: #f0f9ff;
    }
    .tab-btn[aria-selected="true"] {
      background: #e0f2fe;
      box-shadow: 0 0 0 3px rgba(34,195,238,0.2) inset;
    }
    
    /* 工作區域樣式 */
    .workspace-frame {
      border: 4px solid #22c3ee;
      border-radius: 48px;
      padding: 30px;
      background: white;
      min-height: 400px;
      max-width: 1100px;
      margin: 0 auto;
      position: relative;
    }
    
    /* 原有的疊圖樣式 */
    .overlay-stage { position: relative; display: inline-block; }
    .overlay-stage > img { display: block; max-width: 100%; height: auto; }
    .tag { position: absolute; box-sizing: border-box; border-radius: 4px; padding: 0 4px; line-height: 1; display: flex; align-items: center; justify-content: center; font-family: monospace; }
    .tag.chord { background: rgba(0,0,0,.88); color: #ffd700; font-weight: 700; }
    .tag.lyric { background: rgba(255,255,255,.75); color: #111; border: 1px solid #e5e7eb; }
    
    /* 按鈕樣式 */
    #to-export-btn, #to-transpose-btn, #transpose-btn, #recognize-btn {
      position: relative;
      z-index: 10;
      cursor: pointer;
      padding: 8px 16px;
      background: #f8f8f8;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-top: 10px;
    }
    
    /* 確保疊圖中的標籤不會攔截點擊事件 */
    .overlay-stage .tag {
      pointer-events: none;
    }
    .overlay-stage:hover .tag {
      pointer-events: auto;
    }
    
    /* 上傳區域與檔案預覽樣式 */
    .upload-area {
      border: 2px dashed #22c3ee;
      border-radius: 10px;
      padding: 40px 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    .upload-area:hover {
      background-color: #f0f9ff;
      border-color: #0891b2;
    }
    .upload-area .upload-icon {
      margin: 0 auto 15px;
    }

    /* 工作區提示文字 */
    .workspace-hint {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #0891b2;
      font-size: 18px;
    }

    /* 檔案預覽樣式 */
    .file-preview-area {
      margin: 20px 0;
      border-radius: 10px;
      overflow: hidden;
      background: #f8f8f8;
    }
    .file-info {
      padding: 10px 15px;
      background: #e0f2fe;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .file-name {
      font-weight: bold;
      color: #0891b2;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .file-size {
      color: #555;
      font-size: 0.9em;
    }
    .preview-container {
      padding: 15px;
      text-align: center;
      overflow: hidden; /* 確保溢出的內容被隱藏 */
      min-height: 600px; /* 提供足夠的空間給放大後的圖片 */
    }
    .preview-container img {
      max-width: 100%;  /* 保持寬度適應容器 */
      max-height: 600px; /* 從原本的 300px 放大到 600px */
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      transform: scale(2); /* 加入縮放效果 */
      transform-origin: center top; /* 從中央頂部開始縮放 */
      margin: 80px 0; /* 增加上下邊距以容納放大的內容 */
    }

    /* 按鈕樣式統一 */
    #recognize-btn, #to-transpose-btn, #transpose-btn, #to-export-btn {
      background-color: #22c3ee;
      color: white;
      border: none;
      border-radius: 25px;
      padding: 10px 20px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-top: 15px;
    }
    #recognize-btn:hover, #to-transpose-btn:hover, #transpose-btn:hover, #to-export-btn:hover {
      background-color: #0891b2;
    }
    #recognize-btn:disabled {
      background-color: #ccc;
      cursor: not-allowed;
    }

    /* 辨識編輯分頁樣式 */
    .recognition-container {
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin-bottom: 20px;
    }
    .recognition-compare-area {
      display: flex;
      gap: 20px;
      align-items: flex-start;
    }
    .original-image-container,
    .recognition-result-container {
      flex: 1;
      min-width: 0;
    }
    .recognition-result-area {
      flex: 3;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .edit-panel {
      width: 100%;
      background: #f8f8f8;
      border-radius: 10px;
      padding: 15px;
    }
    #text-editor {
      width: 100%;
      min-height: 600px;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-family: monospace;
      font-size: 14px;
      line-height: 1.5;
      resize: vertical;
    }
    .original-image-container,
    .recognition-result-container {
      flex: 1;
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 10px;
      min-height: 400px;
      display: flex;
      flex-direction: column;
    }
    .original-image-container h3,
    .recognition-result-container h3 {
      margin-top: 0;
      color: #0891b2;
      font-size: 18px;
      margin-bottom: 10px;
    }
    #recognition-status {
      font-size: 14px;
      color: #888;
      font-weight: normal;
    }
    .recognition-controls {
      display: flex;
      justify-content: space-between;
      margin-top: 20px;
    }
    .overlay-container {
      flex: 1;
      position: relative;
      border: 1px dashed #ccc;
      background-color: #fcfcfc;
      overflow: auto;
    }
    .edit-tools {
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap;
    }
    .edit-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      background-color: #e0f2fe;
      color: #0891b2;
      border: none;
      padding: 8px 16px;
      border-radius: 20px;
      cursor: pointer;
      font-weight: bold;
    }
    .edit-btn:hover {
      background-color: #bae6fd;
    }
    .edit-options {
      margin-top: 15px;
      padding: 12px;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 8px;
    }
    .edit-option {
      margin-bottom: 12px;
    }
    .edit-option label {
      display: block;
      margin-bottom: 5px;
      color: #555;
      font-size: 14px;
    }
    .edit-option select, 
    .edit-option input {
      width: 100%;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .edit-actions {
      display: flex;
      gap: 10px;
    }
    .edit-action-btn {
      flex: 1;
      padding: 8px;
      border: none;
      border-radius: 4px;
      background-color: #22c3ee;
      color: white;
      cursor: pointer;
    }
    .edit-action-btn.danger {
      background-color: #ff6b6b;
    }
    .edit-action-btn:hover {
      opacity: 0.9;
    }
    .edit-help {
      background: #f0f9ff;
      border-radius: 8px;
      padding: 12px;
      margin-top: 20px;
    }
    .edit-help h4 {
      margin-top: 0;
      color: #0891b2;
      font-size: 16px;
      margin-bottom: 8px;
    }
    .edit-help ul {
      margin: 0;
      padding-left: 20px;
      color: #555;
    }
    .edit-help li {
      margin-bottom: 6px;
      font-size: 14px;
    }
    .action-btn {
      padding: 10px 20px;
      border-radius: 25px;
      border: none;
      font-weight: bold;
      cursor: pointer;
    }
    .action-btn.primary {
      background-color: #22c3ee;
      color: white;
    }
    .action-btn.secondary {
      background-color: #e0f2fe;
      color: #0891b2;
      border: 1px solid #bae6fd;
    }
    .action-btn:hover {
      opacity: 0.9;
    }
    /* 和弦與歌詞的可編輯樣式 */
    .tag.editable {
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .tag.editable:hover {
      box-shadow: 0 0 0 2px rgba(34, 195, 238, 0.5);
    }
    .tag.editable.selected {
      box-shadow: 0 0 0 3px #22c3ee;
    }
    .tag.chord.editable {
      border: 1px dashed #ffd700;
    }
    .tag.lyric.editable {
      border: 1px dashed #22c3ee;
    }
    /* 新增項目的提示樣式 */
    .add-item-hint {
      position: absolute;
      background-color: rgba(34, 195, 238, 0.1);
      border: 2px dashed #22c3ee;
      padding: 15px;
      border-radius: 8px;
      color: #0891b2;
      font-size: 14px;
      text-align: center;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .overlay-container.edit-mode:hover .add-item-hint {
      opacity: 1;
    }

    /* 辨識編輯頁面並排顯示樣式 */
    .recognition-container {
      display: flex;
      flex-direction: column;
      gap: 20px;
      margin-bottom: 20px;
    }

    /* 原始圖與辨識結果並排 */
    .recognition-compare-area {
      display: flex;
      gap: 20px;
      width: 100%;
    }

    .original-image-container,
    .recognition-result-container {
      flex: 1;
      background: #fff;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 10px;
      min-height: 400px;
      display: flex;
      flex-direction: column;
    }

    .original-image-container h3,
    .recognition-result-container h3 {
      margin-top: 0;
      color: #0891b2;
      font-size: 18px;
      margin-bottom: 10px;
    }

    /* 圖片容器樣式 */
    .image-container {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .image-container img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
    }

    /* 辨識結果容器 */
    .overlay-container {
      flex: 1;
      position: relative;
      border: 1px dashed #ccc;
      background-color: #fcfcfc;
      overflow: auto;
    }

    /* 編輯面板置於下方 */
    .edit-panel {
      width: 100%;
      background: #f8f8f8;
      border-radius: 10px;
      padding: 15px;
    }

    /* 工具列排成水平 */
    .edit-tools {
      display: flex;
      gap: 20px;
      align-items: center;
      flex-wrap: wrap;
    }

    /* 可編輯標籤樣式 */
    .tag.editable {
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .tag.editable:hover {
      box-shadow: 0 0 0 2px rgba(34, 195, 238, 0.5);
    }

    .tag.editable.selected {
      box-shadow: 0 0 0 3px #22c3ee;
    }
    .tag.chord.editable {
      border: 1px dashed #ffd700;
    }
    .tag.lyric.editable {
      border: 1px dashed #22c3ee;
    }
    /* 文字模式切換列 */
    .result-mode-switch { display:flex; gap:8px; align-items:center; margin:6px 0 10px; }
    .mode-btn {
      padding:6px 10px; border:1px solid #bae6fd; border-radius:9999px;
      background:#e0f2fe; color:#0891b2; font-weight:700; cursor:pointer;
    }
    .mode-btn.active { background:#22c3ee; color:#fff; border-color:#22c3ee; }

    /* 純文字編輯器 */
    #text-editor-wrap { margin-top:8px; }
    #text-editor {
      width:100%; height:360px; resize:vertical;
      white-space:pre; line-height:1.6;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      border:1px solid #e5e7eb; border-radius:8px; padding:10px;
      background:#fff;
    }

    /* 文字工具列 */
    .text-tools { display:flex; gap:8px; justify-content:flex-end; margin:6px 0; }
    .tool-btn { padding:6px 10px; border:1px solid #d1d5db; border-radius:6px; background:#fff; cursor:pointer; font-size:12px; }
    .tool-btn:hover { background:#f3f4f6; }
    .tool-btn.primary { background:#22c3ee; color:#fff; border-color:#22c3ee; }

    /* Gemini API Key 卡片 */
    .apikey-card { border:1px solid #e5e7eb; border-radius:10px; padding:12px; margin:14px 0; background:#f9fafb; }
    .apikey-card h3 { margin:0 0 8px; font-size:16px; color:#374151; }
    .apikey-row { display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap; }
    #gemini-api-key { flex:1; min-width:280px; padding:8px 10px; border:1px solid #d1d5db; border-radius:6px; }
    .key-btn, #recognize-ai-btn { padding:8px 12px; border:1px solid #d1d5db; border-radius:6px; background:#fff; cursor:pointer; }
    .key-btn:hover, #recognize-ai-btn:hover { background:#f3f4f6; }
    #recognize-ai-btn.primary { background:#10b981; color:#fff; border-color:#10b981; }
    #gemini-status { font-size:12px; color:#6b7280; min-height:18px; }
  </style>
</head>
<body>
  <!-- 頁面標題與分頁導航 -->
  <header class="app-header">
    <h1 class="app-title">簡譜和弦轉換</h1>
    <nav class="tabs" role="tablist">
      <button class="tab-btn" role="tab" id="tab-upload" data-view="upload" aria-selected="true">讀取</button>
      <button class="tab-btn" role="tab" id="tab-recognition" data-view="recognition" aria-selected="false">辨識編輯</button>
      <button class="tab-btn" role="tab" id="tab-transpose" data-view="transpose" aria-selected="false">移調</button>
      <button class="tab-btn" role="tab" id="tab-export" data-view="export" aria-selected="false">匯出</button>
    </nav>
  </header>

  <!-- 工作區框架 -->
  <main class="workspace-frame">
    <!-- 讀取分頁 -->
    <section id="upload-section">
      <!-- 上傳區域 -->
      <div class="upload-area" id="drop-area">
        <input id="file-input" type="file" accept=".jpg,.jpeg,.png,.pdf" style="display: none;" />
        <div class="upload-icon">
          <svg width="48" height="48" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M12 16.5V6.5M12 6.5L7.5 11M12 6.5L16.5 11" stroke="#22c3ee" stroke-width="2" stroke-linecap="round"/>
            <path d="M3 15v4a2 2 0 002 2h14a2 2 0 002-2v-4" stroke="#22c3ee" stroke-width="2" stroke-linecap="round"/>
          </svg>
        </div>
        <p>拖曱檔案到這裡或點擊上傳</p>
        <p><small>支援格式：JPG, PNG, PDF</small></p>
      </div>
      
      <!-- 檔案資訊與預覽區域 (初始隱藏) -->
      <div class="file-preview-area hidden" id="file-preview-area">
        <div class="file-info">
          <span class="file-name" id="file-name">未選擇檔案</span>
          <span class="file-size" id="file-size"></span>
        </div>
        <div class="preview-container" id="file-preview-container">
          <!-- 預覽圖將由 JS 插入 -->
        </div>
      </div>
      
      <!-- Gemini AI 辨識區域 -->
      <div class="apikey-card" id="gemini-card">
        <h3>AI 辨識（Google Gemini）</h3>
        <div class="apikey-row">
          <input id="gemini-api-key" type="password" placeholder="輸入你的 Gemini API key（僅存於本機）" />
          <button id="save-gemini-key" class="key-btn">儲存金鑰</button>
          <button id="clear-gemini-key" class="key-btn">清除</button>
        </div>
        <div class="apikey-row">
          <label><input type="checkbox" id="use-gemini-ai" /> 啟用 AI 辨識</label>
          <button id="recognize-ai-btn" type="button" class="primary" disabled>使用 AI 辨識</button>
          <span id="gemini-status"></span>
        </div>
      </div>
    </section>

    <!-- 辨識編輯分頁 -->
    <section id="recognition-section" class="hidden">
      <div class="recognition-container">
        <!-- 左右對照區域 -->
        <div class="recognition-compare-area">
          <div class="original-image-container">
            <h3>原始圖片</h3>
            <div id="original-image" class="image-container"></div>
          </div>
          <div class="recognition-result-container">
            <h3>辨識結果 <span id="recognition-status">(待開始)</span></h3>
            <div id="text-editor-wrap">
              <div class="text-tools">
                <button id="copy-text" class="tool-btn">複製</button>
                <button id="clear-text" class="tool-btn">清空</button>
                <button id="apply-text" class="tool-btn primary">套用到匯出</button>
                <button id="show-log" class="tool-btn">顯示 Log</button>
              </div>
              <textarea id="text-editor" placeholder="辨識完成後會自動轉換為文字，您可直接編輯…"></textarea>
              <!-- Gemini API Log 顯示區域 -->
              <div id="gemini-log" class="hidden" style="margin-top: 10px; padding: 10px; background: #f5f5f5; border-radius: 4px; max-height: 200px; overflow-y: auto;">
                <h4 style="margin: 0 0 10px 0; color: #666;">Gemini API 回傳 Log：</h4>
                <pre id="gemini-log-content" style="margin: 0; font-size: 12px; color: #333; white-space: pre-wrap;"></pre>
              </div>
            </div>
          </div>
        </div>
        <!-- 底部：編輯工具面板 -->
        <div class="edit-panel"></div>
      </div>
      <div class="recognition-controls">
        <button id="recognize-again" class="action-btn secondary">重新辨識</button>
        <button id="to-transpose-btn" class="action-btn primary">下一步：移調</button>
      </div>
    </section>

    <!-- 移調分頁 -->
    <section id="transpose-section" class="hidden">
      <div>
        <label>原調
          <select id="original-key">
            <option>C</option><option>C#</option><option>D</option><option>D#</option><option>E</option><option>F</option>
            <option>F#</option><option>G</option><option>G#</option><option>A</option><option>A#</option><option>B</option>
          </select>
        </label>
        <label>→ 目標
          <select id="target-key">
            <option>C</option><option>C#</option><option>D</option><option>D#</option><option>E</option><option>F</option>
            <option>F#</option><option>G</option><option>G#</option><option>A</option><option>A#</option><option>B</option>
          </select>
        </label>
        <button id="transpose-btn">套用移調</button>
      </div>
      <div id="transposed-result" style="margin-top:15px;"></div>
      <button id="to-export-btn" style="margin-top:15px;">下一步：匯出</button>
    </section>

    <!-- 匯出分頁 -->
    <section id="export-section" class="hidden">
      <div id="final-preview"></div>
    </section>
    

    
  </main>

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
  <script src="https://docs.opencv.org/4.8.0/opencv.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/music-chord-parser@0.1.2/dist/music-chord-parser.min.js"></script>
  <!-- 新增模組腳本（上傳 / 移調 / 匯出） -->
  <script src="public/js/upload-module.js"></script>
  <script src="public/js/transpose-module.js"></script>
  <script src="public/js/export-module.js"></script>
  <!-- AI 直接辨識模組（取代 OCR 強化處理） -->
  <script src="public/js/ai-direct-recognition.js"></script>
 <script>
        // ========================================================================
        // 全域狀態管理
        // ========================================================================
        window.AppState = {
            preURL: null,
            tokens: [],
            currentTranspose: 0
        };

        // ========================================================================
        // DOM 元素參考
        // ========================================================================
        const elements = {
            fileInput: document.getElementById('file-input'),
            startBtn: document.getElementById('start-recognition-btn'),
            aiBtn: document.getElementById('recognize-ai-btn'),
            apiKeyInput: document.getElementById('gemini-api-key'),
            useAiCheckbox: document.getElementById('use-gemini-ai'),
            recognitionStatus: document.getElementById('recognition-status'),
            geminiStatus: document.getElementById('gemini-status'),
            originalImage: document.getElementById('original-image'),
            recognitionResult: document.getElementById('recognition-result'),
            textEditor: document.getElementById('text-editor'),
        };

        // ========================================================================
        // 事件監聽與 UI 更新
        // ========================================================================

        // 檔案選擇處理
        elements.fileInput.addEventListener('change', function() {
            const file = this.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    window.AppState.preURL = e.target.result;
                    elements.originalImage.innerHTML = `<img src="${e.target.result}" alt="原始圖片" style="max-width: 100%; height: auto;">`;
                    updateAIButtonState();
                };
                reader.readAsDataURL(file);
            } else {
                window.AppState.preURL = null;
                elements.originalImage.innerHTML = '';
                updateAIButtonState();
            }
        });

        // 更新 AI 按鈕狀態的邏輯
        function updateAIButtonState() {
            const hasFile = !!window.AppState.preURL;
            const hasKey = elements.apiKeyInput.value.trim().length > 0;
            const useAI = elements.useAiCheckbox.checked;
            elements.aiBtn.disabled = !(hasFile && hasKey && useAI);
        }

        elements.apiKeyInput.addEventListener('input', updateAIButtonState);
        elements.useAiCheckbox.addEventListener('change', updateAIButtonState);

        // AI 辨識按鈕點擊事件
        elements.aiBtn.addEventListener('click', async function onAIClick(e) {
            e.preventDefault();
            const resultEl = ensureRecognitionResult();
            if (!AppState.preURL) { elements.geminiStatus.textContent = '錯誤：請先選擇檔案'; return; }
            const apiKey = elements.apiKeyInput.value.trim();
            if (!apiKey) { elements.geminiStatus.textContent = '錯誤：請輸入 API 金鑰'; return; }

            elements.geminiStatus.textContent = 'AI 辨識啟動中...';
            elements.aiBtn.disabled = true;
            withPreservedScroll(() => { resultEl.innerHTML = '<em>辨識中...</em>'; });

            try {
                const raw = await callGeminiAPI(AppState.preURL, apiKey, buildPrompt());
                console.log('[AI] Gemini 原始回傳:', raw);

                let tokens = [];
                try {
                    const clean = raw.replace(/^```json\s*|```$/g, '').trim();
                    const json = JSON.parse(clean);
                    if (Array.isArray(json.lines)) {
                        json.lines.forEach(l => {
                            if (l.chords) tokens.push({ kind: 'chord_line', text: l.chords });
                            if (l.lyrics) tokens.push({ kind: 'lyric', text: l.lyrics });
                        });
                    } else throw new Error('缺少 lines');
                } catch (err) {
                    console.warn('[Parser] JSON 失敗 → 改純文字解析:', err.message);
                    tokens = parsePlainTextToTokens(raw);
                }
                AppState.tokens = tokens;
                renderTokens();
                elements.geminiStatus.textContent = 'AI 辨識完成';
            } catch (err) {
                console.error('[AI] 錯誤:', err);
                let msg = err.message || '未知錯誤';
                if (/503|overloaded/i.test(msg)) msg = '伺服器過載，稍後再試';
                if (/inlineData/i.test(msg)) msg = '影像資料為空，檢查檔案讀取流程';
                elements.geminiStatus.textContent = 'AI 辨識錯誤：' + msg;
                withPreservedScroll(() => { resultEl.innerHTML = '<span style="color:#c00;">辨識失敗</span>'; });
            } finally {
                elements.aiBtn.disabled = false;
                updateAIButtonState();
            }
        });

        // ========================================================================
        // Gemini API 相關函式 (已整合所有修正)
        // ========================================================================

        /**
         * 建立一個結構化的提示詞，要求 Gemini 回傳 JSON 格式。
         */
        function buildPrompt() {
            const jsonSchema = { "lines": [{ "chords": "包含和弦與 | 分隔符的字串", "lyrics": "對應的歌詞字串" }] };
            return `你是樂譜辨識專家，專門將圖片中的和弦與歌詞轉換為結構化的 JSON 資料。\n任務：\n1. 辨識圖片中的所有和弦與歌詞。\n2. 和弦行與歌詞行必須分開。\n3. **嚴格**按照以下 JSON 格式回傳結果，不要包含任何額外的說明文字或 markdown 符號。\n\nJSON 格式範例：\n${JSON.stringify(jsonSchema, null, 2)}\n\n現在，請根據使用者提供的圖片，產生對應的 JSON 資料。`;
        }

        /**
         * 呼叫 Gemini API 的主要函式。
         */
        async function callGeminiAPI(imageUrlOrBlob, apiKey, prompt) {
            console.log('[Gemini] 啟動 API 呼叫...');
            try {
                const { mimeType, base64 } = await resolveImageSource(imageUrlOrBlob);
                if (!base64) throw new Error('影像轉換後，base64 資料依然為空，請求中止。');

                const requestBody = {
                    contents: [{ parts: [{ text: prompt }, { inlineData: { mimeType, data: base64 } }] }],
                    generationConfig: { temperature: 0.1, maxOutputTokens: 4096 }
                };

                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;
                const response = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) });

                if (!response.ok) {
                    const errorText = await response.text().catch(() => '無法讀取錯誤內文');
                    throw new Error(`API 回應錯誤: ${response.status} - ${errorText}`);
                }

                const result = await response.json();
                const textContent = result?.candidates?.[0]?.content?.parts?.map(p => p.text).filter(Boolean).join('\n');
                if (!textContent) {
                    console.warn('[Gemini] API 回應中未包含文字內容，回傳原始 JSON。');
                    return JSON.stringify(result);
                }
                return textContent;
            } catch (error) {
                console.error('[Gemini] API 呼叫失敗:', error);
                throw error;
            }
        }

        /**
         * 輔助函式：將各種影像來源解析為 { mimeType, base64 } 物件。
         */
        async function resolveImageSource(src) {
            if (typeof src === 'string' && src.startsWith('data:')) {
                const match = src.match(/^data:([^;]+);base64,(.*)$/);
                if (!match || !match[2]) throw new Error('無效的 data:URL');
                return { mimeType: match[1], base64: match[2] };
            }
            if (src instanceof Blob || (typeof src === 'string' && (src.startsWith('blob:') || src.startsWith('http')))) {
                const response = await (src instanceof Blob ? Promise.resolve(new Response(src)) : fetch(src));
                if (!response.ok) throw new Error(`無法擷取資源: ${response.status}`);
                const blob = await response.blob();
                if (!blob || blob.size === 0) throw new Error('Blob 物件為空');
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onerror = () => reject(new Error('FileReader 讀取錯誤'));
                    reader.onloadend = () => {
                        const res = reader.result;
                        if (typeof res !== 'string') return reject(new Error('FileReader 結果無效'));
                        const match = res.match(/^data:([^;]+);base64,(.*)$/);
                        if (!match || !match[2]) return reject(new Error('無法從 data:URL 解析 base64'));
                        resolve({ mimeType: match[1] || blob.type, base64: match[2] });
                    };
                    reader.readAsDataURL(blob);
                });
            }
            throw new Error('不支援的影像來源格式');
        }

        // ========================================================================
        // 渲染與後備解析函式
        // ========================================================================

        /**
         * 將 tokens 渲染到畫面上。
         */
        function renderTokens() {
            const container = ensureRecognitionResult();
            withPreservedScroll(() => {
                const list = Array.isArray(AppState.tokens) ? AppState.tokens : [];
                const frag = document.createDocumentFragment();
                container.innerHTML = '';
                if (list.length === 0) {
                    container.textContent = '沒有辨識到任何內容。';
                    return;
                }
                for (const token of list) {
                    const div = document.createElement('div');
                    div.className = `tag ${token.kind && token.kind.includes('chord') ? 'chord' : 'lyric'}`;
                    div.textContent = token.text;
                    frag.appendChild(div);
                }
                container.appendChild(frag);
            });
        }

        /**
         * 後備函式：當 JSON 解析失敗時，嘗試解析純文字。
         */
        function parsePlainTextToTokens(text) {
            const lines = text.trim().split('\n');
            const tokens = [];
            const chordLineRegex = /[A-G][#b]?m?(sus|maj|dim|\d)?(\/[A-G][#b]?)?/;
            lines.forEach((line, index) => {
                if (!line.trim()) return;
                const kind = (line.includes('|') || chordLineRegex.test(line)) ? 'chord_line' : 'lyric';
                tokens.push({ kind, text: line, y: 20 + index * 30 });
            });
            return tokens;
        }

        // ========================================================================
        // 初始化
        // ========================================================================
        document.addEventListener('DOMContentLoaded', () => {
            updateAIButtonState();
            console.log('[App] 腳本初始化完成。');
        });

        // ===== 新增：安全確保 recognitionResult 元素存在 =====
        function ensureRecognitionResult() {
            if (elements.recognitionResult instanceof HTMLElement) return elements.recognitionResult;
            let el = document.getElementById('recognition-result');
            if (!el) {
                el = document.createElement('div');
                el.id = 'recognition-result';
                el.style.minHeight = '160px';
                el.style.border = '1px solid #ccc';
                el.style.padding = '8px';
                (document.getElementById('result-container') || document.body).appendChild(el);
                console.warn('[App] 動態建立 recognition-result 容器');
            }
            elements.recognitionResult = el;
            return el;
        }

        /* ========== 檔案讀取：確保存成 dataURL ========== */
if (elements.fileInput) {
  elements.fileInput.addEventListener('change', function() {
    const file = this.files && this.files[0];
    if (!file) { AppState.preURL = null; return; }
    const fr = new FileReader();
    fr.onload = e => {
      AppState.preURL = e.target.result;            // dataURL
      console.log('[File] dataURL 長度', AppState.preURL.length);
    };
    fr.readAsDataURL(file);
  });
}

/* ========== 影像來源解析 ========== */
async function resolveImageSource(src) {
  if (!src) throw new Error('缺少影像來源');
  // 已是 dataURL
  if (typeof src === 'string' && src.startsWith('data:')) {
    const m = src.match(/^data:([^;]+);base64,(.*)$/);
    if (!m || !m[2]) throw new Error('data:URL 無效');
    return { mimeType: m[1], base64: m[2] };
  }
  // blob:/http
  if (typeof src === 'string' && (src.startsWith('blob:') || src.startsWith('http'))) {
    const resp = await fetch(src);
    if (!resp.ok) throw new Error('擷取影像失敗 ' + resp.status);
    const blob = await resp.blob();
    return blobToBase64(blob);
  }
  if (src instanceof Blob) return blobToBase64(src);
  throw new Error('不支援的影像來源型別');
}

function blobToBase64(blob) {
  if (!blob || !blob.size) return Promise.reject(new Error('Blob 為空'));
  return new Promise((res, rej) => {
    const fr = new FileReader();
    fr.onerror = () => rej(new Error('FileReader 失敗'));
    fr.onloadend = () => {
      if (typeof fr.result !== 'string') return rej(new Error('FileReader 結果型別錯誤'));
      const m = fr.result.match(/^data:([^;]+);base64,(.*)$/);
      if (!m || !m[2]) return rej(new Error('無法解析 base64'));
      res({ mimeType: m[1], base64: m[2] });
    };
    fr.readAsDataURL(blob);
  });
}

/* ========== Gemini API 呼叫（強化除錯） ========== */
async function callGeminiAPI(imageSource, apiKey, prompt) {
  console.log('[API] 準備解析影像來源...');
  const { mimeType, base64 } = await resolveImageSource(imageSource);
  console.log('[API] mimeType=', mimeType, 'base64Len=', base64.length);
  if (base64.length < 50) throw new Error('影像 base64 長度異常，可能讀取失敗');

  const body = {
    contents: [{
      parts: [
        { text: prompt },
        { inlineData: { mimeType, data: base64 } }
      ]
    }],
    generationConfig: { temperature: 0.1, maxOutputTokens: 4096 }
  };
  console.log('[API] 請求內容 (截斷):', JSON.stringify(body).slice(0, 180) + '...');

  const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;
  const resp = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type':'application/json' },
    body: JSON.stringify(body)
  });
  if (!resp.ok) {
    const t = await resp.text().catch(()=> '');
    throw new Error(`Gemini API 錯誤 ${resp.status}: ${t}`);
  }
  const json = await resp.json();
  const txt = json?.candidates?.[0]?.content?.parts?.map(p=>p.text).filter(Boolean).join('\n') || '';
  console.log('[API] 回傳文字長度=', txt.length);
  return txt || JSON.stringify(json);
}

/* ---------- 取得或建立結果 textarea ---------- */
function getOrCreateResultTextarea() {
    let ta = document.getElementById('recognition-text');
    if (ta && ta.tagName === 'TEXTAREA') return ta;
    const host = document.getElementById('recognition-result') || ensureRecognitionResult();
    // 若 host 是 textarea 則直接回傳
    if (host.tagName === 'TEXTAREA') return host;
    // 建立
    ta = document.createElement('textarea');
    ta.id = 'recognition-text';
    ta.style.width = '100%';
    ta.style.height = '520px';
    ta.style.fontFamily = 'monospace';
    ta.style.fontSize = '14px';
    ta.style.lineHeight = '1.4';
    ta.style.whiteSpace = 'pre';   // 保留空格
    ta.wrap = 'off';
    host.innerHTML = '';
    host.appendChild(ta);
    console.warn('[GeminiUI] 建立結果文字欄');
    return ta;
}

/* ---------- 顯示原始 Gemini 回傳 ---------- */
function showGeminiRaw(raw) {
    AppState.geminiRaw = raw;
    const ta = getOrCreateResultTextarea();
    ta.value = raw; // 原樣
    console.log('[GeminiUI] 已寫入文字欄, rawLen=', raw.length);
}

/* ---------- 修正：保留空格解析 ---------- */
function processGeminiText(raw) {
    const lines = raw.replace(/\r/g,'').split('\n');
    const tokens = [];
    for (let i=0;i<lines.length;i++){
        let line = lines[i];
        if (line === undefined) continue;
        if (line === '') continue; // 空行略過（可改成 tokens.push({kind:'blank',text:''})
        const trimmed = line.trim();
        if (!trimmed) continue;
        if (isChordLineForClassification(trimmed)) {
            tokens.push({ kind:'chords', text: line }); // 保留原空格
            const next = lines[i+1];
            if (next !== undefined && next.trim() && !isChordLineForClassification(next.trim())) {
                tokens.push({ kind:'lyric', text: next });
                i++;
            }
        } else {
            tokens.push({ kind:'lyric', text: line });
        }
    }
    return tokens;
}

function isChordLineForClassification(t) {
    if (t.includes('|')) return true;
    const CH = /([A-G][#b]?)(maj7|maj9|maj|add9|sus2|sus4|sus|dim7|dim|aug|m7b5|m7|m9|m6|m|7|6|9|11|13)?(\/[A-G][#b]?)?/;
    const re = new RegExp(`^(${CH.source})(\\s+${CH.source})*$`);
    return re.test(t);
}

/* ---------- 渲染 tokens（不覆蓋 textarea 原文） ---------- */
function renderTokens() {
    const ta = getOrCreateResultTextarea();
    let preview = document.getElementById('tokens-preview-block');
    if (!preview) {
        preview = document.createElement('div');
        preview.id = 'tokens-preview-block';
        preview.style.marginTop = '12px';
        preview.style.padding = '8px';
        preview.style.border = '1px solid #e2e2e2';
        preview.style.fontFamily = 'monospace';
        preview.style.whiteSpace = 'pre';
        ta.parentNode.appendChild(preview);
    }
    preview.innerHTML = '';
    const list = Array.isArray(AppState.tokens) ? AppState.tokens : [];
    if (!list.length) {
        preview.textContent = '（無拆分結果）';
        return;
    }
    const frag = document.createDocumentFragment();
    list.forEach(t=>{
        const lineEl = document.createElement('div');
        lineEl.className = 'token-line ' + (t.kind === 'chords' ? 'token-chords':'token-lyric');
        lineEl.style.whiteSpace = 'pre';
        lineEl.style.fontFamily = 'monospace';
        if (t.kind === 'chords') lineEl.style.fontWeight = '600';
        lineEl.textContent = t.text; // 保留空格
        frag.appendChild(lineEl);
    });
    preview.appendChild(frag);
}

/* ---------- 呼叫 API（確保 base64） ---------- */
async function callGeminiAPI(imageSource, apiKey, prompt) {
    const { mimeType, base64 } = await resolveImageSource(imageSource);
    console.log('[API] mimeType=', mimeType, 'base64Len=', base64.length);
    if (base64.length < 50) throw new Error('影像 base64 長度異常，可能讀取失敗');

    const body = {
        contents:[{ parts:[ { text: prompt }, { inlineData:{ mimeType, data: base64 } } ] }],
        generationConfig:{ temperature:0.1, maxOutputTokens:4096 }
    };
    const url=`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;
    const r = await fetch(url,{
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body:JSON.stringify(body)
    });
    if(!r.ok){
        const txt=await r.text().catch(()=> '');
        throw new Error(`Gemini API 錯誤 ${r.status}: ${txt}`);
    }
    const json=await r.json();
    const text=json?.candidates?.[0]?.content?.parts?.map(p=>p.text).filter(Boolean).join('\n')||'';
    console.log('[API] 回傳文字長度=', text.length);
    return text || JSON.stringify(json);
}

/* ---------- AI 按鈕事件（核心） ---------- */
// 找到舊的 events.aiBtn 監聽並替換
if (elements.aiBtn) {
    elements.aiBtn.replaceWith(elements.aiBtn.cloneNode(true));
    elements.aiBtn = document.getElementById('recognize-ai-btn');
    elements.aiBtn.addEventListener('click', async (e)=>{
        e.preventDefault();
        if(!AppState.preURL){ elements.geminiStatus.textContent='請先選擇圖片'; return; }
        const key = elements.apiKeyInput.value.trim();
        if(!key){ elements.geminiStatus.textContent='請輸入 API 金鑰'; return; }
        elements.aiBtn.disabled = true;
        elements.geminiStatus.textContent='辨識中...';

        try{
            const raw = await callGeminiAPI(AppState.preURL, key, buildPrompt());
            showGeminiRaw(raw); // 立刻顯示原始
            AppState.tokens = processGeminiText(raw);
            renderTokens();
            elements.geminiStatus.textContent='完成';
        }catch(err){
            console.error('[Gemini] 失敗', err);
            elements.geminiStatus.textContent='錯誤: '+err.message;
        }finally{
            elements.aiBtn.disabled=false;
        }
    });
}

/* ---------- 確保檔案讀取為 dataURL ---------- */
if (elements.fileInput) {
    elements.fileInput.addEventListener('change', function(){
        const f=this.files&&this.files[0];
        if(!f){ AppState.preURL=null; return; }
        const fr=new FileReader();
        fr.onload=e=>{
            AppState.preURL=e.target.result;
            console.log('[File] dataURL 長度=', AppState.preURL.length);
        };
        fr.readAsDataURL(f);
    });
}

// ...existing code...
</script>
<script>
// 防重入
(function (g, d) {
  if (g.__GeminiUIBootLoaded) return; g.__GeminiUIBootLoaded = true;

  // 1) 忽略 Pouch 404 錯誤，避免中斷
  function isPouchErr(e) {
    const n = (e && e.name) || '';
    const m = (e && (e.message || e.reason || '')) + '';
    const s = (e && e.status) || 0;
    return /pouch/i.test(n + m) || n === 'not_found' || s === 404;
  }
  g.addEventListener('error', ev => { const e = ev.error || ev.message || {}; if (isPouchErr(e)) { ev.preventDefault?.(); console.warn('[ignore] Pouch error', e); } });
  g.addEventListener('unhandledrejection', ev => { const r = ev.reason || {}; if (isPouchErr(r)) { ev.preventDefault?.(); console.warn('[ignore] Pouch rejection', r); } });

  // 2) 元件
  const $ = id => d.getElementById(id);
  const keyInput = $('gemini-api-key');
  const useCk    = $('use-gemini-ai');
  const aiBtn    = $('recognize-ai-btn');
  const recBtn   = $('recognize-btn');
  const fileIn   = $('file-input');
  const statusAI = $('gemini-status');
  const statusR  = $('recognition-status') || $('upload-status');
  const imgBox   = $('original-image') || $('recognition-result');

  // 3) 啟用邏輯
  function syncRecognizeBtn() {
    if (!fileIn || !recBtn) return;
    recBtn.disabled = !(fileIn.files && fileIn.files.length > 0);
  }
  function syncAIBtn() {
    if (!aiBtn) return;
    const hasKey = !!(keyInput && keyInput.value.trim());
    const enabled = (!!useCk ? useCk.checked : true) && hasKey;
    aiBtn.disabled = !enabled;
  }

  // 4) 取得目前影像 URL（檔案/已有預覽/AppState）
  function currentImageURL() {
    if (fileIn && fileIn.files && fileIn.files[0]) {
      try { return URL.createObjectURL(fileIn.files[0]); } catch (_) {}
    }
    if (g.AppState && g.AppState.preURL) return g.AppState.preURL;
    const img = imgBox && imgBox.querySelector && imgBox.querySelector('img');
    if (img && img.src) return img.src;
    return '';
  }

  // 5) 後備顯示（當沒有 performRecognition）
  function fallbackPreview(url) {
    if (!imgBox || !url) return;
    imgBox.innerHTML = '';
    const img = new Image();
    img.src = url;
    img.style.maxWidth = '100%';
    img.style.height = 'auto';
    imgBox.appendChild(img);
  }

  // 6) 點擊處理：開始辨識（沿用既有 recBtn）
  async function onRecognizeClick() {
    try {
      const url = currentImageURL();
      if (!url) { statusR && (statusR.textContent = '尚未選擇檔案'); return; }
      g.AppState = g.AppState || {}; g.AppState.preURL = url;
      if (typeof g.performRecognition === 'function') {
        statusR && (statusR.textContent = '開始辨識中...');
        await g.performRecognition(url);
        statusR && (statusR.textContent = '辨識完成');
        d.dispatchEvent(new CustomEvent('app:recognition-finished'));
      } else {
        fallbackPreview(url);
        statusR && (statusR.textContent = '(後備) 辨識完成');
        d.dispatchEvent(new CustomEvent('app:recognition-finished'));
      }
    } catch (e) {
      console.error('[recognize]', e);
      statusR && (statusR.textContent = '辨識錯誤：' + (e.message || e));
    }
  }

  // 7) 點擊處理：AI 辨識（Gemini）
  async function onAIClick() {
    try {
      const key = keyInput ? keyInput.value.trim() : '';
      if (!key) { statusAI && (statusAI.textContent = '請輸入 API key'); return; }
      const url = currentImageURL();
      if (!url) { statusAI && (statusAI.textContent = '請先選擇或載入影像'); return; }

      statusAI && (statusAI.textContent = 'AI 辨識執行中...');
      statusR && (statusR.textContent = '開始 AI 辨識...');
      g.AppState = g.AppState || {}; g.AppState.preURL = url;

      // 顯示原圖
      fallbackPreview(url);

      try {
        // 呼叫真正的 Gemini API
        const result = await callGeminiAPI(key, url);
        
        // 記錄 API 回傳結果
        if (typeof g.setGeminiLog === 'function') {
          g.setGeminiLog({
            timestamp: new Date().toISOString(),
            request: {
              apiKey: key.substring(0, 10) + '...',
              imageUrl: url.substring(0, 50) + '...',
              model: 'gemini-1.5-flash'
            },
            response: result
          });
        }

        // 解析 API 回應並轉換為 tokens
        const tokens = parseGeminiResponse(result);
        g.AppState.tokens = tokens;

        // 更新文字編輯器
        if (typeof g.updateTextEditor === 'function') {
          g.updateTextEditor(tokens);
        }

        statusR && (statusR.textContent = `AI 辨識完成，找到 ${tokens.length} 個項目`);
        statusAI && (statusAI.textContent = 'AI 辨識完成');
        
      } catch (apiError) {
        console.error('[Gemini API]', apiError);
        
        // 記錄錯誤
        if (typeof g.setGeminiLog === 'function') {
          g.setGeminiLog({
            timestamp: new Date().toISOString(),
            request: {
              apiKey: key.substring(0, 10) + '...',
              imageUrl: url.substring(0, 50) + '...',
              model: 'gemini-1.5-flash'
            },
            error: {
              message: apiError.message,
              stack: apiError.stack
            }
          });
        }

        // API 失敗時使用後備方案
        statusAI && (statusAI.textContent = 'API 呼叫失敗，使用後備辨識');
        g.AppState.tokens = [
          { kind: 'chord', x: 20, y: 20, w: 40, h: 20, text: 'C' },
          { kind: 'chord', x: 80, y: 20, w: 40, h: 20, text: 'F' },
          { kind: 'chord', x: 140, y: 20, w: 40, h: 20, text: 'G' },
          { kind: 'lyric', x: 20, y: 50, w: 160, h: 20, text: '後備辨識結果' },
        ];
        
        if (typeof g.updateTextEditor === 'function') {
          g.updateTextEditor(g.AppState.tokens);
        }
        statusR && (statusR.textContent = '(後備) 辨識完成');
      }

      d.dispatchEvent(new CustomEvent('app:recognition-finished'));
    } catch (e) {
      console.error('[gemini]', e);
      statusAI && (statusAI.textContent = 'AI 辨識錯誤：' + (e.message || e));
    }
  }

  // Gemini API 呼叫函式
  async function callGeminiAPI(apiKey, imageUrl) {
    // 將 data URL 轉換為 base64
    const base64Data = imageUrl.split(',')[1];
    
    const payload = {
      contents: [{
        parts: [{
          text: g.buildPrompt()
        }, {
          inline_data: {
            mime_type: "image/png",
            data: base64Data
          }
        }]
      }]
    };

    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(payload)
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      throw new Error(`Gemini API 錯誤: ${response.status} - ${errorData.error?.message || response.statusText}`);
    }

    const data = await response.json();
    return data;
  }

  // 解析 Gemini 回應
  function parseGeminiResponse(response) {
    try {
      const text = response.candidates?.[0]?.content?.parts?.[0]?.text || '';
      console.log('[Gemini Response Text]', text);
      
      // 嘗試從回應中提取和弦和歌詞
      const lines = text.split('\n').filter(line => line.trim());
      const tokens = [];
      let yPos = 20;
      
      lines.forEach((line, index) => {
        const trimmedLine = line.trim();
        if (!trimmedLine) return;
        
        // 更全面的和弦辨識模式，包括中文樂譜常見的格式
        const chordPatterns = [
          // 基本和弦模式：A, Am, A7, Amaj7, A#, Bb/D 等
          /\|([A-G][#b]?(?:maj|min|m|sus|dim|aug|add|[0-9]+)*(?:\/[A-G][#b]?)?)[\s]*\|/g,
          // 簡單和弦模式（無縱線）
          /\b([A-G][#b]?(?:maj|min|m|sus|dim|aug|add|[0-9]+)*(?:\/[A-G][#b]?)?)\b/g
        ];
        
        let isChordLine = false;
        let chords = [];
        
        // 嘗試用不同的模式匹配和弦
        for (const pattern of chordPatterns) {
          const matches = trimmedLine.match(pattern);
          if (matches && matches.length > 0) {
            chords = matches.map(match => match.replace(/[\|\s]/g, '').trim()).filter(c => c);
            if (chords.length > 0) {
              isChordLine = true;
              break;
            }
          }
        }
        
        // 判斷是否為和弦行（包含縱線或多個大寫字母）
        if (!isChordLine) {
          isChordLine = /\|.*\|/.test(trimmedLine) || 
                       (trimmedLine.match(/[A-G]/g) || []).length >= 2;
        }
        
        if (isChordLine && chords.length > 0) {
          // 這行包含和弦
          let xPos = 20;
          chords.forEach(chord => {
            if (chord && chord.length > 0) {
              tokens.push({
                kind: 'chord',
                x: xPos,
                y: yPos,
                w: Math.max(30, chord.length * 12),
                h: 20,
                text: chord
              });
              xPos += Math.max(40, chord.length * 15);
            }
          });
        } else if (trimmedLine.length > 0) {
          // 這行是歌詞或其他文字
          tokens.push({
            kind: 'lyric',
            x: 20,
            y: yPos,
            w: Math.max(100, trimmedLine.length * 10),
            h: 20,
            text: trimmedLine
          });
        }
        yPos += 35;
      });
      
      return tokens.length > 0 ? tokens : [
        { kind: 'lyric', x: 20, y: 20, w: 200, h: 20, text: '無法解析 Gemini 回應\n\n原始回應：' + text.substring(0, 100) + '...' }
      ];
      
    } catch (e) {
      console.error('[Parse Gemini Response]', e);
      return [
        { kind: 'lyric', x: 20, y: 20, w: 200, h: 20, text: '解析回應時發生錯誤：' + e.message }
      ];
    }
  }

  // 8) 綁定事件
  function wire() {
    if (fileIn)  fileIn.addEventListener('change', () => { syncRecognizeBtn(); /* 選檔後預存 URL */ g.AppState = g.AppState || {}; g.AppState.preURL = currentImageURL(); });
    if (recBtn && !recBtn.__wired) { recBtn.addEventListener('click', onRecognizeClick); recBtn.__wired = true; }
    if (keyInput) keyInput.addEventListener('input', syncAIBtn);
    if (useCk)    useCk.addEventListener('change', syncAIBtn);
    if (aiBtn && !aiBtn.__wired) { aiBtn.addEventListener('click', onAIClick); aiBtn.__wired = true; }

    // 分頁切換：定義並導出 switchView
    if (typeof g.switchView !== 'function') {
      g.switchView = function(view){
        const views = {
          upload: 'upload-section',
          recognition: 'recognition-section',
          transpose: 'transpose-section',
          export: 'export-section'
        };
        const tabs = {
          upload: d.getElementById('tab-upload'),
          recognition: d.getElementById('tab-recognition'),
          transpose: d.getElementById('tab-transpose'),
          export: d.getElementById('tab-export')
        };
        // 切換區塊顯示
        Object.values(views).forEach(id => { const el = d.getElementById(id); el && el.classList.add('hidden'); });
        const targetId = views[view];
        const target = targetId ? d.getElementById(targetId) : null;
        if (target) target.classList.remove('hidden');
        // 切換 tab 樣式
        Object.values(tabs).forEach(tb => { if (tb) tb.setAttribute('aria-selected', 'false'); });
        const activeTab = tabs[view];
        if (activeTab) activeTab.setAttribute('aria-selected', 'true');
        return view;
      };
    }

    // Tab 點擊導覽
    const tabBtns = d.querySelectorAll('.tab-btn[data-view]');
    tabBtns.forEach(btn => {
      if (!btn.__wired) {
        btn.addEventListener('click', () => { const v = btn.getAttribute('data-view'); if (v) g.switchView(v); });
        btn.__wired = true;
      }
    });

    // 下一步按鈕：辨識 → 移調、移調 → 匯出
    const toTranspose = d.getElementById('to-transpose-btn');
    if (toTranspose && !toTranspose.__wired) { toTranspose.addEventListener('click', () => g.switchView('transpose')); toTranspose.__wired = true; }
    const toExport = d.getElementById('to-export-btn');
    if (toExport && !toExport.__wired) { toExport.addEventListener('click', () => g.switchView('export')); toExport.__wired = true; }

    // 辨識完成後，自動切到「辨識編輯」分頁，確保可見，並更新文字編輯器
    d.addEventListener('app:recognition-finished', () => { 
      g.switchView('recognition'); 
      // 確保文字編輯器顯示最新的辨識結果
      if (typeof g.updateTextEditor === 'function' && g.AppState?.tokens) {
        g.updateTextEditor(g.AppState.tokens);
      }
    });

    syncRecognizeBtn(); syncAIBtn();
  }
  if (d.readyState === 'loading') d.addEventListener('DOMContentLoaded', wire, { once: true }); else wire();

  // 9) buildPrompt 函式（為 Gemini API 提供詳細提示）
  if (typeof g.buildPrompt !== 'function') {
    g.buildPrompt = function () {
      return `你是一個專業的音樂譜辨識專家。請仔細辨識這張中文歌譜圖片中的所有內容。

**辨識規則：**
1. 辨識所有的和弦符號（通常在歌詞上方，如：F, C, Dm7, Bb2, G#等）
2. 辨識所有的中文歌詞
3. 請按照從上到下、從左到右的順序讀取

**輸出格式：**
直接輸出每一行的內容，和弦和歌詞各自一行。

**範例：**
|F  |C  |Dm7 /C |Bb2 |
在你的院宇中歌唱
|F  |C  |Dm7    |Bb  |
讚美你的聖名

**重要：**
- 如果看到类似 |F2| 或 |Csus| 的格式，請完整保留
- 不要忽略任何歌詞或和弦
- 保持原有的行的結構和格式
- 直接輸出，不要加任何解釋或說明`;
    };
  }
})(window, document);
</script>
<!-- OCR 改善腳本已移除，現在主要使用 Gemini API 進行辨識 -->
<script src="public/js/recognition-skip-ocr-when-tokens.js"></script>
<script>
(function (g, d) {
  if (g.__GeminiAPIFixLoaded) return;
  g.__GeminiAPIFixLoaded = true;

  const log = (...a) => console.log('[GeminiFix]', ...a);
  const warn = (...a) => console.warn('[GeminiFix]', ...a);
  const err = (...a) => console.error('[GeminiFix]', ...a);

  // 將任意來源轉成 { mimeType, base64 }
  async function resolveImageToBase64(src) {
    try {
      // 1) data:URL
      if (typeof src === 'string' && src.startsWith('data:')) {
        const m = src.match(/^data:([^;]+);base64,(.*)$/);
        if (!m || !m[2]) throw new Error('data:URL 內容為空');
        return { mimeType: m[1] || 'image/png', base64: m[2] };
      }

      // 2) blob: URL 或 http(s) URL
      if (typeof src === 'string' && (src.startsWith('blob:') || /^https?:/.test(src))) {
        const resp = await fetch(src);
        if (!resp.ok) throw new Error(`fetch 失敗: ${resp.status}`);
        const blob = await resp.blob();
        return blobToResolvedImage(blob);
      }

      // 3) Blob/File
      if (src instanceof Blob) {
        const { mimeType, base64 } = await blobToResolvedImage(src);
        return { mimeType, base64 };
      }

      // 4) 後備：若沒提供或格式不符，嘗試使用 AppState.preURL
      if (g.AppState?.preURL) {
        return await resolveImageToBase64(g.AppState.preURL);
      }

      throw new Error('不支援的影像來源，且找不到 AppState.preURL');
    } catch (e) {
      err('resolveImageToBase64 失敗', e);
      throw e;
    }
  }

  function blobToResolvedImage(blob) {
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onerror = () => reject(new Error('FileReader 讀取失敗'));
      fr.onloadend = () => {
        const result = fr.result;
        if (typeof result !== 'string') return reject(new Error('FileReader 結果無效'));
        const m = result.match(/^data:([^;]+);base64,(.*)$/);
        if (!m || !m[2]) return reject(new Error('無法自 data:URL 提取 base64'));
        resolve({ mimeType: m[1] || (blob.type || 'image/png'), base64: m[2] });
      };
      fr.readAsDataURL(blob);
    });
  }

  async function callGeminiAPIFixed(imageUrlOrBlob, apiKey, prompt) {
    const startedAt = Date.now();
    try {
      // 統一從來源取得 base64 與正確的 mime
      const source = g.AppState?.preURL || imageUrlOrBlob;
      const { mimeType, base64 } = await resolveImageToBase64(source);
      if (!base64) throw new Error('inlineData base64 為空');

      const body = {
        contents: [{
          parts: [
            { text: prompt || (typeof g.buildPrompt === 'function' ? g.buildPrompt() : '請萃取和弦與歌詞') },
            { inlineData: {
                mimeType,
                data: base64
              }
            }
          ]
        }],
        generationConfig: { temperature: 0.1, topK: 32, topP: 1, maxOutputTokens: 4096 }
      };

      const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;
      const res = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body) });

      if (!res.ok) {
        const text = await res.text().catch(() => '');
        throw new Error(`Gemini API 錯誤: ${res.status} - ${text || '未知錯誤'}`);
      }

      const json = await res.json();
      log('API 成功，用時(ms):', Date.now() - startedAt);
      // 取第一段文字
      const text = json?.candidates?.[0]?.content?.parts?.map(p => p.text).filter(Boolean).join('\n');
      if (!text) warn('回傳沒有文字部分，原樣回傳 JSON');
      return text || JSON.stringify(json);
    } catch (e) {
      const errorLog = {
        timestamp: new Date().toISOString(),
        request: {
          apiKey: apiKey ? String(apiKey).slice(0, 8) + '...' : '未提供',
          imageUrl: typeof imageUrlOrBlob === 'string' ? imageUrlOrBlob : (g.AppState?.preURL ? '[AppState.preURL]' : '[Blob]'),
          model: 'gemini-1.5-flash'
        },
        error: { message: e.message, stack: e.stack }
      };
      err('Gemini API 回傳 Log：\n' + JSON.stringify(errorLog, null, 2));
      throw e;
    }
  }

 

  // 覆寫全域呼叫
  const prev = g.callGeminiAPI;
  g.callGeminiAPI = callGeminiAPIFixed;
  log('修正載入完成，原函式型別:', typeof prev);
})(window, document);
</script>
<!-- 請將此區塊貼在 </body> 標籤之前 -->
<script>
  // 確保所有程式碼在一個立即執行的函式 (IIFE) 中，避免汙染全域範圍
  (function (g, d) {
    // 防止腳本重複載入
    if (g.__CHORD_TRANSPOSE_APP_LOADED__) return;
    g.__CHORD_TRANSPOSE_APP_LOADED__ = true;

    console.log('[App] 腳本啟動');

    // 全域狀態
    g.AppState = g.AppState || {
      rawURL: null, // 原始檔案的 URL
      preURL: null, // 預處理後的圖片 URL (此處等於 rawURL)
      tokens: [],   // 辨識出的 token
      geminiLog: null // Gemini API 的日誌
    };

    // DOM 元素快取
    const $ = id => d.getElementById(id);
    const elements = {
      fileInput: $('file-input'),
      apiKeyInput: $('gemini-api-key'),
      useAiCheckbox: $('use-gemini-ai'),
      aiBtn: $('recognize-ai-btn'),
      recBtn: $('recognize-btn'),
      geminiStatus: $('gemini-status'),
      recognitionStatus: $('recognition-status'),
      originalImage: $('original-image'),
      recognitionResult: $('recognition-result'),
      textEditor: $('text-editor'),
      showLogBtn: $('show-log'),
      geminiLogDiv: $('gemini-log'),
      geminiLogContent: $('gemini-log-content')
    };

    /**
     * 更新 AI 辨識按鈕的狀態
     */
    function syncAIBtn() {
      if (!elements.aiBtn) return;
      const hasKey = !!(elements.apiKeyInput && elements.apiKeyInput.value.trim());
      const useAI = !!(elements.useAiCheckbox && elements.useAiCheckbox.checked);
      const hasFile = !!(elements.fileInput && elements.fileInput.files.length > 0);
      elements.aiBtn.disabled = !(useAI && hasKey && hasFile);
    }

    /**
     * 取得目前要辨識的圖片 URL
     */
    function getCurrentImageURL() {
      if (g.AppState.preURL) return g.AppState.preURL;
      if (elements.fileInput && elements.fileInput.files[0]) {
        try {
          const url = URL.createObjectURL(elements.fileInput.files[0]);
          g.AppState.preURL = url; // 快取 URL
          return url;
        } catch (e) {
          console.error('無法建立 Object URL', e);
          return null;
        }
      }
      return null;
    }

    /**
     * 將 Blob 或 data:URL 轉換為 Base64 字串
     */
    function blobToResolvedImage(blob) {
      return new Promise((resolve, reject) => {
        if (!blob || blob.size === 0) {
          return reject(new Error('Blob 物件為空'));
        }
        const reader = new FileReader();
        reader.onerror = () => reject(new Error('FileReader 讀取時發生錯誤'));
        reader.onloadend = () => {
          const result = reader.result;
          if (typeof result !== 'string') {
            return reject(new Error('FileReader 讀取結果無效'));
          }
          const match = result.match(/^data:([^;]+);base64,(.*)$/);
          if (!match || !match[2]) {
            return reject(new Error('無法從 data:URL 解析 base64 資料'));
          }
          resolve({ mimeType: match[1] || blob.type, base64: match[2] });
        };
        reader.readAsDataURL(blob);
      });
    }

    /**
     * 解析各種影像來源，最終回傳 { mimeType, base64 }
     */
    async function resolveImageSource(src) {
      if (typeof src !== 'string' || !src) {
        throw new Error('無效的影像來源');
      }
      if (src.startsWith('data:')) {
        const match = src.match(/^data:([^;]+);base64,(.*)$/);
        if (!match || !match[2]) throw new Error('無效的 data:URL 格式');
        return { mimeType: match[1], base64: match[2] };
      }
      if (src.startsWith('blob:') || src.startsWith('http')) {
        const response = await fetch(src);
        if (!response.ok) throw new Error(`無法擷取資源: ${response.status}`);
        const blob = await response.blob();
        return blobToResolvedImage(blob);
      }
      throw new Error('不支援的影像來源格式');
    }

    /**
     * 建立傳送給 Gemini API 的提示
     */
    function buildPrompt() {
      return `請你扮演一位精準的樂譜文字辨識專家。你的任務是將我上傳的樂譜圖片，轉換為排版精確、易于複製的純文字格式。

請嚴格遵守以下排版規則：

完整標題資訊：擷取並放在最上方，包含歌曲名稱、調性 (Key) 和速度 (BPM)。

保留歌曲結構：清楚標示出所有段落標題，例如：Intro (前奏)、Verse (主歌)、Pre-Chorus (導歌)、Chorus (副歌)、Bridge (橋段)、Outro (尾奏) 等。

和弦在上，歌詞在下：和弦必須在歌詞的正上方，並且分成兩行獨立呈現。

精準對位：將每個和弦精確地對齊在對應的歌詞（或單字）上方，這是最重要的要求。

保留所有音樂符號：完整保留圖片中的所有音樂符號，特別是：

小節線：|

和弦變化：例如 Dm7, Csus4, G/B 等複雜和弦。

使用等寬字體格式：請將最終結果放入一個程式碼區塊 (Code Block) 中，以確保對齊不會因字體而跑掉。

格式範例如下：

[歌曲名稱]

[段落標題]
|[和弦]  |[和弦]      |[和弦]
 [歌詞]   [對齊的歌詞] [對齊的歌詞]
請開始辨識我上傳的檔案，並嚴格按照以上規則產出結果。`;
    }

    /**
     * 呼叫 Gemini API
     */
    async function callGeminiAPI(imageUrl, apiKey, prompt) {
      console.log('[API] 準備解析影像來源...');
      const { mimeType, base64 } = await resolveImageSource(imageUrl);
      console.log('[API] mimeType=', mimeType, 'base64Len=', base64.length);
      if (base64.length < 50) throw new Error('影像 base64 長度異常，可能讀取失敗');

      const body = {
        contents: [{
          parts: [
            { text: prompt },
            { inlineData: { mimeType, data: base64 } }
          ]
        }],
        generationConfig: { temperature: 0.1, maxOutputTokens: 4096 }
      };
      console.log('[API] 請求內容 (截斷):', JSON.stringify(body).slice(0, 180) + '...');

      const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`;
      const resp = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type':'application/json' },
        body: JSON.stringify(body)
      });
      if (!resp.ok) {
        const t = await resp.text().catch(()=> '');
        throw new Error(`Gemini API 錯誤 ${resp.status}: ${t}`);
      }
      const json = await resp.json();
      const text = json?.candidates?.[0]?.content?.parts?.map(p => p.text).filter(Boolean).join('\n') || '';
      console.log('[API] 回傳文字長度=', text.length);
      return text || JSON.stringify(json);
    }

    /**
     * 解析 Gemini 回傳的純文字 (這部分是之前解析失敗的地方)
     */
    function parseGeminiResponseToTokens(responseText) {
        // 這個解析器很基本，所以可能會失敗，但我們保留它來重現之前的狀態
        console.log('[Parser] 嘗試解析純文字:', responseText);
        const tokens = [{
            kind: 'lyric',
            text: `無法解析 Gemini 回應\n\n原始回應：\n${responseText}`,
            x: 10, y: 10, w: 400, h: 100
        }];
        // 即使解析失敗，我們也回傳一個 token，讓 UI 顯示錯誤訊息
        return tokens;
    }

    /**
     * 渲染 Tokens 到畫面上
     */
    function renderTokens(tokens) {
        if (!elements.recognitionResult) return;
        elements.recognitionResult.innerHTML = '';
        (tokens || []).forEach(token => {
            const el = document.createElement('div');
            el.className = `tag ${token.kind}`;
            el.textContent = token.text;
            el.style.cssText = `position: absolute; left: ${token.x}px; top: ${token.y}px; width: ${token.w}px; height: ${token.h}px;`;
            elements.recognitionResult.appendChild(el);
        });
        // 同時更新文字編輯器
        if (elements.textEditor) {
            elements.textEditor.value = (tokens || []).map(t => t.text).join('\n');
        }
    }

    // --- 事件綁定 ---

    // 檔案輸入
    elements.fileInput?.addEventListener('change', () => {
      g.AppState.preURL = null; // 清除舊的 URL
      const url = getCurrentImageURL();
      if (url && elements.originalImage) {
        elements.originalImage.innerHTML = `<img src="${url}" style="max-width:100%; height:auto;">`;
      }
      syncAIBtn();
    });

    // AI 辨識按鈕
    elements.aiBtn?.addEventListener('click', async () => {
      const apiKey = elements.apiKeyInput?.value.trim();
      const imageUrl = getCurrentImageURL();

      if (!apiKey) {
        elements.geminiStatus.textContent = '請輸入 API 金鑰';
        return;
      }
      if (!imageUrl) {
        elements.geminiStatus.textContent = '請先選擇一個影像檔案';
        return;
      }

      elements.geminiStatus.textContent = 'AI 辨識執行中...';
      try {
        const responseText = await callGeminiAPI(imageUrl, apiKey, buildPrompt());
        console.log('[AI] Gemini 原始回傳:', responseText);
        
        const tokens = parseGeminiResponseToTokens(responseText);
        g.AppState.tokens = tokens;
        
        renderTokens(tokens);
        elements.geminiStatus.textContent = 'AI 辨識完成';
        
      } catch (error) {
        console.error('[AI] 辨識流程失敗:', error);
        elements.geminiStatus.textContent = `錯誤: ${error.message}`;
        renderTokens([{ kind: 'error', text: `辨識失敗：${error.message}`, x:10, y:10, w:400, h:50 }]);
      }
    });

    // 顯示 Log 按鈕
    elements.showLogBtn?.addEventListener('click', () => {
        if (!elements.geminiLogDiv || !elements.geminiLogContent) return;

        if (elements.geminiLogDiv.classList.toggle('hidden')) {
            return; // 如果是隱藏，就直接結束
        }

        if (g.AppState.geminiLog) {
            elements.geminiLogContent.textContent = JSON.stringify(g.AppState.geminiLog, null, 2);
        } else {
            elements.geminiLogContent.textContent = '尚無 Gemini API 的日誌紀錄。';
        }
    });

    // 初始化按鈕狀態
    syncAIBtn();
    console.log('[App] 初始化完成');

  })(window, document);
</script>
</body>
</html>
