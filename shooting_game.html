<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>九九乘法打擊敵機遊戲 (精靈球版)</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 自定義字體 */
        body {
            font-family: "Inter", sans-serif;
        }
        /* 確保 canvas 佔用其父容器的可用空間 */
        canvas {
            display: block;
            background-color: #a7f3d0; /* 淺綠色背景 */
            border-bottom: 2px solid #9ca3af; /* 灰色邊框 */
            border-radius: 0.5rem; /* 圓角 */
            width: 100%; /* 佔滿父容器寬度 */
            height: calc(50vh); /* 將高度設定為視口高度的一半 */
        }
        .answer-button {
            /* 放大答案選項 */
            @apply px-12 py-6 text-4xl bg-blue-500 text-white rounded-lg shadow-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-400;
        }
        .answer-button:disabled {
            @apply bg-gray-400 cursor-not-allowed;
        }
        .celebration-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 3rem;
            font-weight: bold;
            text-align: center;
            z-index: 100;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen bg-gray-100 p-4 relative">
    <div id="game-area" class="w-full max-w-3xl bg-white rounded-lg shadow-lg overflow-hidden flex flex-col">
        <!-- 遊戲畫布區域 -->
        <canvas id="gameCanvas"></canvas>

        <!-- 遊戲控制和資訊區域 -->
        <div class="p-4 bg-gray-50 flex flex-col items-center justify-center text-center rounded-b-lg">
            <div class="text-lg font-semibold mb-2 flex justify-between w-full px-4">
                <span id="scoreDisplay">分數: 0</span>
                <span id="timerDisplay">時間: 40s</span>
            </div>
            <!-- 問題顯示區域 -->
            <div class="text-4xl font-bold mb-4 text-center w-full">
                <span id="questionDisplay">點擊開始遊戲</span>
            </div>
            <!-- 答案選項區域 -->
            <div id="answerOptionsContainer" class="grid grid-cols-2 gap-4 mb-4 w-full max-w-sm">
                <!-- 答案按鈕將由 JavaScript 動態生成 -->
            </div>
            <!-- 答題時間條 -->
            <div class="h-2 bg-gray-300 rounded-full mt-4 overflow-hidden w-full max-w-xs">
                <div id="questionTimerBar" class="h-full bg-green-500 transition-all duration-100 ease-linear" style="width: 100%;"></div>
            </div>
            <!-- 回饋訊息顯示區域 -->
            <div id="feedbackDisplay" class="mt-2 text-red-600 font-semibold h-6"></div>
            <!-- 開始/重新開始遊戲按鈕 -->
            <button
                id="startGameButton"
                class="mt-4 px-6 py-3 bg-blue-600 text-white text-xl font-bold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
                開始遊戲
            </button>
            <!-- 特殊大砲按鈕 -->
            <button
                id="specialCannonButton"
                class="mt-2 px-4 py-2 bg-purple-600 text-white text-lg font-bold rounded-lg shadow-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 hidden"
            >
                發射大砲！
            </button>
        </div>
    </div>

    <!-- 慶賀畫面 -->
    <div id="celebrationScreen" class="celebration-screen hidden">
        <p>恭喜過關！</p>
        <p>分數: <span id="finalScore">0</span></p>
        <button id="restartGameButton" class="mt-8 px-6 py-3 bg-green-600 text-white text-xl font-bold rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500">
            再玩一次
        </button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const timerDisplay = document.getElementById('timerDisplay');
        const questionDisplay = document.getElementById('questionDisplay');
        const answerOptionsContainer = document.getElementById('answerOptionsContainer');
        const questionTimerBar = document.getElementById('questionTimerBar');
        const feedbackDisplay = document.getElementById('feedbackDisplay');
        const startGameButton = document.getElementById('startGameButton');
        const specialCannonButton = document.getElementById('specialCannonButton');
        const celebrationScreen = document.getElementById('celebrationScreen');
        const finalScoreDisplay = document.getElementById('finalScore');
        const restartGameButton = document.getElementById('restartGameButton');

        // --- 圖片載入邏輯 ---
        const playerImage = new Image();
        let isImageLoaded = false;

        // 圖片載入前，禁用開始按鈕
        startGameButton.disabled = true;
        startGameButton.textContent = '圖片載入中...';

        playerImage.onload = () => {
            isImageLoaded = true;
            startGameButton.disabled = false;
            startGameButton.textContent = '開始遊戲';
            console.log('精靈球圖片已載入！');
            // 呼叫 resizeCanvas 來繪製初始的玩家（精靈球）
            resizeCanvas();
        };

        playerImage.onerror = () => {
            console.error('無法載入 poke_ball.png。請確保檔案與 HTML 檔案在同一個資料夾中。');
            startGameButton.textContent = '圖片載入失敗';
            startGameButton.classList.add('bg-red-500', 'cursor-not-allowed');
            feedbackDisplay.textContent = '無法載入精靈球圖片！';
        };

        // 設定圖片來源，這會觸發 onload 或 onerror
        playerImage.src = 'poke_ball.png';
        // --- 圖片載入邏輯結束 ---

        // 遊戲狀態變數
        let score = 0;
        let gameTimer = 40;
        let questionTimer = 5;
        let currentQuestion = { num1: 0, num2: 0, answer: 0 };
        let gameStarted = false;
        let gameOver = false;
        let specialCannonAvailable = false;
        let lastCannonScoreThreshold = 0;

        // 遊戲元素狀態
        let player = null;
        let enemies = [];
        let askedQuestions = new Set();

        // 計時器和動畫幀 ID
        let lastFrameTime = 0;
        let questionStartTime = 0;
        let gameLoopId = null;
        let gameTimerIntervalId = null;
        let questionTimerIntervalId = null;
        let enemySpawnTimer = 0;
        const enemySpawnInterval = 3000;

        // 遊戲設定
        const maxEnemies = 10;
        const enemySpeed = 0.5;
        const WIN_SCORE = 500;

        // --- 修改後的 Player 類別 ---
        class Player {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.image = playerImage; // 直接引用已載入的圖片物件
            }

            draw(ctx) {
                // 檢查圖片是否已載入完成
                if (isImageLoaded && this.image.complete && this.image.naturalWidth !== 0) {
                    ctx.drawImage(this.image, this.x, this.y, this.width, this.height);
                } else {
                    // 如果圖片未載入，繪製一個備用方塊
                    ctx.fillStyle = 'purple';
                    ctx.fillRect(this.x, this.y, this.width, this.height);
                }
            }
        }

        class Enemy {
            constructor(x, y, width, height, color = 'red') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
                this.isHit = false;
            }

            draw(ctx) {
                if (this.isHit) return;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + this.width, this.y + this.height);
                ctx.moveTo(this.x + this.width, this.y);
                ctx.lineTo(this.x, this.y + this.height);
                ctx.stroke();
            }

            update(speed) {
                this.y += speed;
            }
        }

        // 遊戲邏輯函數

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function generateQuestion() {
            let num1, num2, questionString;
            do {
                num1 = Math.floor(Math.random() * 9) + 1;
                num2 = Math.floor(Math.random() * 9) + 1;
                questionString = `${Math.min(num1, num2)}x${Math.max(num1, num2)}`;
            } while (askedQuestions.has(questionString) && askedQuestions.size < 81);

            if (askedQuestions.size === 81) {
                askedQuestions.clear();
            }
            askedQuestions.add(questionString);
            currentQuestion = { num1, num2, answer: num1 * num2 };
            questionDisplay.textContent = `${currentQuestion.num1} x ${currentQuestion.num2} = ?`;
            feedbackDisplay.textContent = '';
            questionStartTime = Date.now();
            resetQuestionTimer();

            const answers = [currentQuestion.answer];
            while (answers.length < 4) {
                let wrongAnswer;
                do {
                    wrongAnswer = Math.floor(Math.random() * 81) + 1;
                } while (answers.includes(wrongAnswer) || Math.abs(wrongAnswer - currentQuestion.answer) < 3);
                answers.push(wrongAnswer);
            }
            shuffleArray(answers);

            answerOptionsContainer.innerHTML = '';
            answers.forEach(ans => {
                const button = document.createElement('button');
                button.textContent = ans;
                button.classList.add('answer-button');
                button.dataset.answer = ans;
                button.addEventListener('click', handleAnswerClick);
                answerOptionsContainer.appendChild(button);
            });
            enableAnswerButtons();
        }

        function enableAnswerButtons() {
            Array.from(answerOptionsContainer.children).forEach(button => {
                button.disabled = false;
            });
        }

        function disableAnswerButtons() {
            Array.from(answerOptionsContainer.children).forEach(button => {
                button.disabled = true;
            });
        }

        function resetQuestionTimer() {
            questionTimer = 5;
            questionTimerBar.style.width = '100%';
            if (questionTimerIntervalId) {
                clearInterval(questionTimerIntervalId);
            }
            questionTimerIntervalId = setInterval(() => {
                questionTimer -= 0.05;
                if (questionTimer <= 0.05) {
                    clearInterval(questionTimerIntervalId);
                    if (gameStarted && !gameOver) {
                        endGame("時間到，你被敵軍打敗了！");
                    }
                    questionTimer = 0;
                }
                questionTimerBar.style.width = `${(questionTimer / 5) * 100}%`;
            }, 50);
        }

        function fireBullet(numTargets, specialCannon = false) {
            if (specialCannon) {
                enemies.forEach(enemy => enemy.isHit = true);
                score += enemies.length * 10;
                feedbackDisplay.textContent = '大砲發射！全滅！';
                specialCannonAvailable = false;
                specialCannonButton.classList.add('hidden');
            } else {
                const enemiesToHit = enemies
                    .filter(enemy => !enemy.isHit)
                    .map(enemy => ({ enemy, distance: Math.hypot(player.x + player.width / 2 - (enemy.x + enemy.width / 2), player.y - enemy.y) }))
                    .sort((a, b) => a.distance - b.distance)
                    .slice(0, numTargets);

                enemiesToHit.forEach(({ enemy }) => {
                    enemy.isHit = true;
                    score += 10;
                });

                if (numTargets === 1) feedbackDisplay.textContent = '殲滅 1 隻敵軍！';
                else if (numTargets === 2) feedbackDisplay.textContent = '殲滅 2 隻敵軍！';
                else if (numTargets === 3) feedbackDisplay.textContent = '殲滅 3 隻敵軍！';
                else if (numTargets >= enemies.length && enemies.length > 0) feedbackDisplay.textContent = '全滅敵軍！';
            }
            scoreDisplay.textContent = `分數: ${score}`;
        }

        function handleAnswerClick(event) {
            if (!gameStarted || gameOver) return;

            const selectedAnswer = parseInt(event.target.dataset.answer, 10);
            disableAnswerButtons();

            if (selectedAnswer === currentQuestion.answer) {
                const answerTime = (Date.now() - questionStartTime) / 1000;
                score += 10;

                let targetsToEliminate = 0;
                if (answerTime <= 2) {
                    targetsToEliminate = enemies.length;
                } else if (answerTime <= 3) {
                    targetsToEliminate = 3;
                } else if (answerTime <= 4) {
                    targetsToEliminate = 2;
                } else if (answerTime <= 5) {
                    targetsToEliminate = 1;
                }
                fireBullet(targetsToEliminate);
                checkSpecialCannonAvailability();
                checkWinCondition();
                generateQuestion();
            } else {
                feedbackDisplay.textContent = '答錯了！再試一次。';
                enableAnswerButtons();
            }
        }

        function checkSpecialCannonAvailability() {
            const currentScoreThreshold = Math.floor(score / 50) * 50;
            if (currentScoreThreshold > lastCannonScoreThreshold && currentScoreThreshold > 0) {
                specialCannonAvailable = true;
                specialCannonButton.classList.remove('hidden');
                feedbackDisplay.textContent = '獲得特殊大砲！';
                lastCannonScoreThreshold = currentScoreThreshold;
            }
        }

        function useSpecialCannon() {
            if (specialCannonAvailable && gameStarted && !gameOver) {
                fireBullet(0, true);
                specialCannonAvailable = false;
                specialCannonButton.classList.add('hidden');
                generateQuestion();
            }
        }

        function checkWinCondition() {
            if (score >= WIN_SCORE) {
                endGame("恭喜過關！", true);
            }
        }

        function spawnEnemy() {
            if (enemies.length < maxEnemies) {
                const x = Math.random() * (canvas.width - 50);
                enemies.push(new Enemy(x, 0, 40, 40));
            }
        }

        function handleCollisions() {
            enemies = enemies.filter(enemy => !enemy.isHit);

            enemies = enemies.filter(enemy => {
                if (enemy.y + enemy.height > canvas.height) {
                    endGame("敵軍突破防線，你被擊敗了！", false);
                    return false;
                }
                return true;
            });
        }

        function update(deltaTime) {
            enemies.forEach(enemy => enemy.update(enemySpeed));

            enemySpawnTimer += deltaTime;
            if (enemySpawnTimer > enemySpawnInterval) {
                spawnEnemy();
                enemySpawnTimer = 0;
            }

            handleCollisions();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (player) {
                player.draw(ctx);
            }

            enemies.forEach(enemy => enemy.draw(ctx));
        }

        function gameLoop(currentTime) {
            if (!gameStarted || gameOver) return;

            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;

            update(deltaTime);
            draw();

            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function startGame() {
            if (!isImageLoaded) {
                feedbackDisplay.textContent = '圖片仍在載入中，請稍候...';
                return;
            }
            hideCelebrationScreen();
            gameStarted = true;
            gameOver = false;
            score = 0;
            gameTimer = 40;
            specialCannonAvailable = false;
            lastCannonScoreThreshold = 0;

            scoreDisplay.textContent = `分數: ${score}`;
            timerDisplay.textContent = `時間: ${gameTimer}s`;
            feedbackDisplay.textContent = '';
            enemies = [];
            askedQuestions.clear();
            enemySpawnTimer = 0;

            // --- 使用修改後的 Player 類別 ---
            player = new Player(
                canvas.width / 2 - 25, // 玩家 X 座標
                canvas.height - 60,    // 玩家 Y 座標
                50,                    // 玩家寬度
                50                     // 玩家高度
            );

            generateQuestion();
            startGameButton.textContent = '重新開始';
            startGameButton.disabled = true;
            specialCannonButton.classList.add('hidden');

            if (gameTimerIntervalId) clearInterval(gameTimerIntervalId);
            gameTimerIntervalId = setInterval(() => {
                gameTimer--;
                timerDisplay.textContent = `時間: ${gameTimer}s`;
                if (gameTimer <= 0) {
                    clearInterval(gameTimerIntervalId);
                    endGame("時間到，遊戲結束！", false);
                }
            }, 1000);

            lastFrameTime = performance.now();
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function endGame(reason, isWin) {
            gameOver = true;
            gameStarted = false;
            feedbackDisplay.textContent = reason + ` 最終分數: ${score}`;

            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            if (gameTimerIntervalId) clearInterval(gameTimerIntervalId);
            if (questionTimerIntervalId) clearInterval(questionTimerIntervalId);

            disableAnswerButtons();
            startGameButton.disabled = false;
            startGameButton.textContent = '重新開始';
            questionDisplay.textContent = '遊戲結束';
            questionTimerBar.style.width = '0%';
            specialCannonButton.classList.add('hidden');

            if (isWin) {
                showCelebrationScreen();
            }
        }

        function showCelebrationScreen() {
            celebrationScreen.classList.remove('hidden');
            finalScoreDisplay.textContent = score;
        }

        function hideCelebrationScreen() {
            celebrationScreen.classList.add('hidden');
        }

        startGameButton.addEventListener('click', startGame);
        specialCannonButton.addEventListener('click', useSpecialCannon);
        restartGameButton.addEventListener('click', startGame);

        function resizeCanvas() {
            const gameArea = document.getElementById('game-area');
            if (gameArea) {
                canvas.width = gameArea.clientWidth;
                canvas.height = window.innerHeight / 2;
            } else {
                canvas.width = window.innerWidth * 0.8;
                canvas.height = window.innerHeight / 2;
            }

            // 遊戲開始前，如果圖片已載入，先畫出玩家
            if (!gameStarted) {
                ctx.clearRect(0, 0, canvas.width, canvas.height); // 清除畫布
                // 創建一個臨時的 player 物件來繪製
                const tempPlayer = new Player(
                    canvas.width / 2 - 25,
                    canvas.height - 60,
                    50,
                    50
                );
                tempPlayer.draw(ctx);
            } else if (player) {
                // 如果遊戲正在進行，更新玩家位置
                player.x = canvas.width / 2 - player.width / 2;
                player.y = canvas.height - 60;
            }
            
            draw(); // 重新繪製整個場景
        }

        window.addEventListener('resize', resizeCanvas);

        // 初始設定畫布大小
        // 使用 setTimeout 確保 DOM 和 CSS 完全加載後再執行
        window.onload = () => {
            setTimeout(resizeCanvas, 100);
        };
    </script>
</body>
</html>
