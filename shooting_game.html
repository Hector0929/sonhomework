<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>九九乘法打擊敵機遊戲</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 自定義字體 */
        body {
            font-family: "Inter", sans-serif;
        }
        /* 確保 canvas 佔用其父容器的可用空間 */
        canvas {
            display: block;
            background-color: #a7f3d0; /* 淺綠色背景 */
            border-bottom: 2px solid #9ca3af; /* 灰色邊框 */
            border-radius: 0.5rem; /* 圓角 */
            width: 100%; /* 佔滿父容器寬度 */
            height: calc(50vh); /* 將高度設定為視口高度的一半 */
        }
        .answer-button {
            /* 放大答案選項 */
            @apply px-12 py-6 text-4xl bg-blue-500 text-white rounded-lg shadow-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-400;
        }
        .answer-button:disabled {
            @apply bg-gray-400 cursor-not-allowed;
        }
        .celebration-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 3rem;
            font-weight: bold;
            text-align: center;
            z-index: 100;
        }
    </style>
</head>
<body class="flex flex-col items-center justify-center min-h-screen bg-gray-100 p-4 relative">
    <div id="game-area" class="w-full max-w-3xl bg-white rounded-lg shadow-lg overflow-hidden flex flex-col">
        <!-- 遊戲畫布區域 -->
        <canvas id="gameCanvas"></canvas>

        <!-- 遊戲控制和資訊區域 -->
        <div class="p-4 bg-gray-50 flex flex-col items-center justify-center text-center rounded-b-lg">
            <div class="text-lg font-semibold mb-2 flex justify-between w-full px-4">
                <span id="scoreDisplay">分數: 0</span>
                <span id="timerDisplay">時間: 40s</span>
            </div>
            <!-- 問題顯示區域 -->
            <div class="text-4xl font-bold mb-4 text-center w-full">
                <span id="questionDisplay">點擊開始遊戲</span>
            </div>
            <!-- 答案選項區域 -->
            <div id="answerOptionsContainer" class="grid grid-cols-2 gap-4 mb-4 w-full max-w-sm">
                <!-- 答案按鈕將由 JavaScript 動態生成 -->
            </div>
            <!-- 答題時間條 -->
            <div class="h-2 bg-gray-300 rounded-full mt-4 overflow-hidden w-full max-w-xs">
                <div id="questionTimerBar" class="h-full bg-green-500 transition-all duration-100 ease-linear" style="width: 100%;"></div>
            </div>
            <!-- 回饋訊息顯示區域 -->
            <div id="feedbackDisplay" class="mt-2 text-red-600 font-semibold h-6"></div>
            <!-- 開始/重新開始遊戲按鈕 -->
            <button
                id="startGameButton"
                class="mt-4 px-6 py-3 bg-blue-600 text-white text-xl font-bold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500"
            >
                開始遊戲
            </button>
            <!-- 特殊大砲按鈕 -->
            <button
                id="specialCannonButton"
                class="mt-2 px-4 py-2 bg-purple-600 text-white text-lg font-bold rounded-lg shadow-md hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-purple-500 hidden"
            >
                發射大砲！
            </button>
        </div>
    </div>

    <!-- 慶賀畫面 -->
    <div id="celebrationScreen" class="celebration-screen hidden">
        <p>恭喜過關！</p>
        <p>分數: <span id="finalScore">0</span></p>
        <button id="restartGameButton" class="mt-8 px-6 py-3 bg-green-600 text-white text-xl font-bold rounded-lg shadow-md hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-green-500">
            再玩一次
        </button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const timerDisplay = document.getElementById('timerDisplay');
        const questionDisplay = document.getElementById('questionDisplay');
        const answerOptionsContainer = document.getElementById('answerOptionsContainer');
        const questionTimerBar = document.getElementById('questionTimerBar');
        const feedbackDisplay = document.getElementById('feedbackDisplay');
        const startGameButton = document.getElementById('startGameButton');
        const specialCannonButton = document.getElementById('specialCannonButton');
        const celebrationScreen = document.getElementById('celebrationScreen');
        const finalScoreDisplay = document.getElementById('finalScore');
        const restartGameButton = document.getElementById('restartGameButton');

        // 遊戲狀態變數
        let score = 0;
        let gameTimer = 40; // 遊戲總時間 (秒)
        let questionTimer = 5; // 每題答題時間 (秒)
        let currentQuestion = { num1: 0, num2: 0, answer: 0 };
        let gameStarted = false;
        let gameOver = false;
        let specialCannonAvailable = false; // 特殊大砲是否可用
        let lastCannonScoreThreshold = 0; // 上一次獲得大砲的分數閾值

        // 遊戲元素狀態
        let player = null;
        let enemies = [];
        let askedQuestions = new Set(); // 已問過的問題集合，避免重複

        // 計時器和動畫幀 ID
        let lastFrameTime = 0;
        let questionStartTime = 0;
        let gameLoopId = null;
        let gameTimerIntervalId = null;
        let questionTimerIntervalId = null;
        let enemySpawnTimer = 0;
        const enemySpawnInterval = 3000; // 敵機生成間隔 (毫秒)，從 1000 改為 3000

        // 遊戲設定
        const maxEnemies = 10;
        const enemySpeed = 0.5; // 敵機速度減緩，從 1 改為 0.5
        const WIN_SCORE = 500; // 過關分數

        // 遊戲元素類別定義
        class Player {
            constructor(x, y, width, height, color = 'blue') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.beginPath();
                ctx.moveTo(this.x + this.width / 2, this.y);
                ctx.lineTo(this.x, this.y + this.height);
                ctx.lineTo(this.x + this.width, this.y + this.height);
                ctx.closePath();
                ctx.fillStyle = 'darkblue';
                ctx.fill();
            }
        }

        class Enemy {
            constructor(x, y, width, height, color = 'red') {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = color;
                this.isHit = false; // 標記是否被大砲擊中
            }

            draw(ctx) {
                if (this.isHit) return; // 如果被標記為擊中，則不繪製
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y);
                ctx.lineTo(this.x + this.width, this.y + this.height);
                ctx.moveTo(this.x + this.width, this.y);
                ctx.lineTo(this.x, this.y + this.height);
                ctx.stroke();
            }

            update(speed) {
                this.y += speed;
            }
        }

        // 遊戲邏輯函數

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function generateQuestion() {
            let num1, num2, questionString;
            do {
                num1 = Math.floor(Math.random() * 9) + 1;
                num2 = Math.floor(Math.random() * 9) + 1;
                questionString = `${Math.min(num1, num2)}x${Math.max(num1, num2)}`;
            } while (askedQuestions.has(questionString) && askedQuestions.size < 81);

            if (askedQuestions.size === 81) {
                askedQuestions.clear();
            }
            askedQuestions.add(questionString);
            currentQuestion = { num1, num2, answer: num1 * num2 };
            questionDisplay.textContent = `${currentQuestion.num1} x ${currentQuestion.num2} = ?`;
            feedbackDisplay.textContent = '';
            questionStartTime = Date.now();
            resetQuestionTimer();

            // 生成錯誤答案
            const answers = [currentQuestion.answer];
            while (answers.length < 4) { // 生成 4 個答案選項
                let wrongAnswer;
                do {
                    wrongAnswer = Math.floor(Math.random() * 81) + 1;
                } while (answers.includes(wrongAnswer) || Math.abs(wrongAnswer - currentQuestion.answer) < 3);
                answers.push(wrongAnswer);
            }
            shuffleArray(answers); // 打亂答案順序

            // 清空舊按鈕並生成新按鈕
            answerOptionsContainer.innerHTML = '';
            answers.forEach(ans => {
                const button = document.createElement('button');
                button.textContent = ans;
                button.classList.add('answer-button');
                button.dataset.answer = ans; // 將答案儲存在 data 屬性中
                button.addEventListener('click', handleAnswerClick);
                answerOptionsContainer.appendChild(button);
            });
            enableAnswerButtons(); // 啟用答案按鈕
        }

        function enableAnswerButtons() {
            Array.from(answerOptionsContainer.children).forEach(button => {
                button.disabled = false;
            });
        }

        function disableAnswerButtons() {
            Array.from(answerOptionsContainer.children).forEach(button => {
                button.disabled = true;
            });
        }

        function resetQuestionTimer() {
            questionTimer = 5; // 重設為 5 秒
            questionTimerBar.style.width = '100%';
            if (questionTimerIntervalId) {
                clearInterval(questionTimerIntervalId);
            }
            questionTimerIntervalId = setInterval(() => {
                questionTimer -= 0.05;
                if (questionTimer <= 0.05) {
                    clearInterval(questionTimerIntervalId);
                    if (gameStarted && !gameOver) {
                        endGame("時間到，你被敵軍打敗了！");
                    }
                    questionTimer = 0;
                }
                questionTimerBar.style.width = `${(questionTimer / 5) * 100}%`; // 根據 5 秒計算寬度
            }, 50);
        }

        // 修正後的 fireBullet 函數，直接處理敵機的消除
        function fireBullet(numTargets, specialCannon = false) {
            if (specialCannon) {
                enemies.forEach(enemy => enemy.isHit = true); // 標記所有敵機為擊中
                score += enemies.length * 10; // 為所有被擊中的敵機加分
                feedbackDisplay.textContent = '大砲發射！全滅！';
                specialCannonAvailable = false;
                specialCannonButton.classList.add('hidden'); // 隱藏大砲按鈕
            } else {
                // 找到距離玩家最近的 numTargets 數量敵機
                const enemiesToHit = enemies
                    .filter(enemy => !enemy.isHit) // 只考慮未被擊中的敵機
                    .map(enemy => ({ enemy, distance: Math.hypot(player.x + player.width / 2 - (enemy.x + enemy.width / 2), player.y - enemy.y) }))
                    .sort((a, b) => a.distance - b.distance)
                    .slice(0, numTargets); // 選擇最近的 N 個

                enemiesToHit.forEach(({ enemy }) => {
                    enemy.isHit = true; // 標記敵機為擊中
                    score += 10; // 為每個被擊中的敵機加分
                });

                if (numTargets === 1) feedbackDisplay.textContent = '殲滅 1 隻敵軍！';
                else if (numTargets === 2) feedbackDisplay.textContent = '殲滅 2 隻敵軍！';
                else if (numTargets === 3) feedbackDisplay.textContent = '殲滅 3 隻敵軍！';
                else if (numTargets >= enemies.length) feedbackDisplay.textContent = '全滅敵軍！'; // 當目標數量大於等於現有敵機數時，顯示全滅
            }
            scoreDisplay.textContent = `分數: ${score}`;
        }

        function handleAnswerClick(event) {
            if (!gameStarted || gameOver) return;

            const selectedAnswer = parseInt(event.target.dataset.answer, 10);
            disableAnswerButtons(); // 點擊後禁用按鈕，避免重複點擊

            if (selectedAnswer === currentQuestion.answer) {
                const answerTime = (Date.now() - questionStartTime) / 1000; // 計算答題時間 (秒)
                score += 10; // 答對加基本分數

                let targetsToEliminate = 0;
                if (answerTime <= 2) { // 2秒全滅
                    targetsToEliminate = enemies.length; // 模擬全滅
                } else if (answerTime <= 3) { // 3秒3隻
                    targetsToEliminate = 3;
                } else if (answerTime <= 4) { // 4秒殲滅2隻
                    targetsToEliminate = 2;
                } else if (answerTime <= 5) { // 5秒殲滅一隻
                    targetsToEliminate = 1;
                }
                fireBullet(targetsToEliminate); // 調用修正後的 fireBullet
                checkSpecialCannonAvailability(); // 檢查特殊大砲是否可用
                checkWinCondition(); // 檢查是否過關
                generateQuestion(); // 生成新問題
            } else {
                feedbackDisplay.textContent = '答錯了！再試一次。';
                // 答錯不立即生成新問題，讓玩家有機會重試或等待時間結束
                enableAnswerButtons(); // 答錯重新啟用按鈕
            }
        }


        function checkSpecialCannonAvailability() {
            // 每 50 分獲得一次大砲，且只在達到新的 50 分閾值時觸發
            const currentScoreThreshold = Math.floor(score / 50) * 50;
            if (currentScoreThreshold > lastCannonScoreThreshold && currentScoreThreshold > 0) {
                specialCannonAvailable = true;
                specialCannonButton.classList.remove('hidden');
                feedbackDisplay.textContent = '獲得特殊大砲！';
                lastCannonScoreThreshold = currentScoreThreshold;
            }
        }

        function useSpecialCannon() {
            if (specialCannonAvailable && gameStarted && !gameOver) {
                fireBullet(0, true); // 0 顆子彈，但觸發特殊大砲邏輯
                specialCannonAvailable = false;
                specialCannonButton.classList.add('hidden');
                generateQuestion(); // 發射大砲後生成新問題
            }
        }

        function checkWinCondition() {
            if (score >= WIN_SCORE) {
                endGame("恭喜過關！", true); // 傳遞 true 表示是過關勝利
            }
        }

        function spawnEnemy() {
            if (enemies.length < maxEnemies) {
                const x = Math.random() * (canvas.width - 50);
                enemies.push(new Enemy(x, 0, 40, 40));
            }
        }

        // 修正後的 handleCollisions 函數，只處理敵機的移除
        function handleCollisions() {
            // 移除被標記為擊中的敵機
            enemies = enemies.filter(enemy => !enemy.isHit);

            // 敵機到達底部 (玩家失敗條件)
            enemies = enemies.filter(enemy => {
                if (enemy.y + enemy.height > canvas.height) {
                    endGame("敵軍突破防線，你被擊敗了！", false); // 傳遞 false 表示是失敗
                    return false;
                }
                return true;
            });
        }

        function update(deltaTime) {
            enemies.forEach(enemy => enemy.update(enemySpeed));

            enemySpawnTimer += deltaTime;
            if (enemySpawnTimer > enemySpawnInterval) {
                spawnEnemy();
                enemySpawnTimer = 0;
            }

            handleCollisions();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (player) {
                player.draw(ctx);
            }

            enemies.forEach(enemy => enemy.draw(ctx));
        }

        function gameLoop(currentTime) {
            if (!gameStarted || gameOver) return;

            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;

            update(deltaTime);
            draw();

            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function startGame() {
            hideCelebrationScreen(); // 隱藏慶賀畫面
            gameStarted = true;
            gameOver = false;
            score = 0;
            gameTimer = 40;
            specialCannonAvailable = false;
            lastCannonScoreThreshold = 0; // 重設大砲閾值

            scoreDisplay.textContent = `分數: ${score}`;
            timerDisplay.textContent = `時間: ${gameTimer}s`;
            feedbackDisplay.textContent = '';
            enemies = [];
            askedQuestions.clear();
            enemySpawnTimer = 0;

            // 初始化玩家位置
            player = new Player(
                canvas.width / 2 - 25,
                canvas.height - 60,
                50,
                50
            );

            generateQuestion();
            startGameButton.textContent = '重新開始';
            startGameButton.disabled = true; // 遊戲開始後禁用按鈕
            specialCannonButton.classList.add('hidden'); // 隱藏大砲按鈕

            if (gameTimerIntervalId) clearInterval(gameTimerIntervalId);
            gameTimerIntervalId = setInterval(() => {
                gameTimer--;
                timerDisplay.textContent = `時間: ${gameTimer}s`;
                if (gameTimer <= 0) {
                    clearInterval(gameTimerIntervalId);
                    endGame("時間到，遊戲結束！", false); // 傳遞 false 表示是失敗
                }
            }, 1000);

            lastFrameTime = performance.now();
            gameLoopId = requestAnimationFrame(gameLoop);
        }

        function endGame(reason, isWin) {
            gameOver = true;
            gameStarted = false;
            feedbackDisplay.textContent = reason + ` 最終分數: ${score}`;

            if (gameLoopId) cancelAnimationFrame(gameLoopId);
            if (gameTimerIntervalId) clearInterval(gameTimerIntervalId);
            if (questionTimerIntervalId) clearInterval(questionTimerIntervalId);

            disableAnswerButtons(); // 禁用答案按鈕
            startGameButton.disabled = false; // 遊戲結束後啟用按鈕
            startGameButton.textContent = '重新開始';
            questionDisplay.textContent = '遊戲結束'; // 顯示遊戲結束
            questionTimerBar.style.width = '0%'; // 時間條清空
            specialCannonButton.classList.add('hidden'); // 隱藏大砲按鈕

            if (isWin) {
                showCelebrationScreen();
            }
        }

        function showCelebrationScreen() {
            celebrationScreen.classList.remove('hidden');
            finalScoreDisplay.textContent = score;
        }

        function hideCelebrationScreen() {
            celebrationScreen.classList.add('hidden');
        }

        // 事件監聽器
        startGameButton.addEventListener('click', startGame);
        specialCannonButton.addEventListener('click', useSpecialCannon);
        restartGameButton.addEventListener('click', startGame); // 慶賀畫面中的重新開始按鈕

        // 畫布響應式調整大小
        function resizeCanvas() {
            const gameArea = document.getElementById('game-area');
            if (gameArea) {
                canvas.width = gameArea.clientWidth;
                canvas.height = window.innerHeight / 2; // 設定為視窗高度的一半
            } else {
                canvas.width = window.innerWidth * 0.8; // 預設值
                canvas.height = window.innerHeight / 2; // 預設值
            }

            // 重新定位玩家
            if (player) {
                player.x = canvas.width / 2 - player.width / 2;
                player.y = canvas.height - 60;
            }
            draw(); // 重新繪製
            // 初始顯示文字
            if (!gameStarted && !gameOver) {
                ctx.font = '24px Arial';
                ctx.fillStyle = 'black';
                ctx.textAlign = 'center';
                ctx.fillText('點擊開始遊戲', canvas.width / 2, canvas.height / 2);
            }
        }

        window.addEventListener('resize', resizeCanvas);

        // 初始設定畫布大小並繪製
        // 使用 setTimeout 確保 DOM 和 CSS 完全加載後再執行 resizeCanvas
        window.onload = () => {
            setTimeout(resizeCanvas, 100);
        };
    </script>
</body>
</html>
